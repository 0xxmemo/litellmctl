#!/usr/bin/env python3
"""
litellmctl wizard — interactive config generator.

Walks the user through selecting providers, models, and fallback chains,
then writes a complete config.yaml (backing up the existing one).

Provider templates and defaults are loaded from templates/*.yaml.
"""

import shutil
import sys
from collections import OrderedDict
from pathlib import Path

import yaml

SCRIPT_DIR = Path(__file__).resolve().parent
PROJECT_DIR = SCRIPT_DIR.parent
TEMPLATES_DIR = PROJECT_DIR / "templates"
CONFIG_FILE = PROJECT_DIR / "config.yaml"

# ── Terminal helpers ────────────────────────────────────────────────────────

_TTY = sys.stdout.isatty()
def _c(t, c): return f"\033[{c}m{t}\033[0m" if _TTY else t
def _green(t):  return _c(t, "32")
def _yellow(t): return _c(t, "33")
def _red(t):    return _c(t, "31")
def _bold(t):   return _c(t, "1")
def _dim(t):    return _c(t, "2")


def _ask(prompt, default=""):
    sys.stdout.write(prompt)
    sys.stdout.flush()
    ans = input().strip()
    return ans if ans else default


def _pick_numbers(prompt, count, default="all"):
    ans = _ask(prompt, default)
    if ans.lower() == "all":
        return list(range(count))
    indices = []
    for part in ans.replace(" ", ",").split(","):
        part = part.strip()
        if part.isdigit() and 1 <= int(part) <= count:
            idx = int(part) - 1
            if idx not in indices:
                indices.append(idx)
    return indices


# ── Template loading ───────────────────────────────────────────────────────

def _load_defaults() -> dict:
    path = TEMPLATES_DIR / "defaults.yaml"
    if not path.exists():
        print(_red(f"Missing {path}"))
        sys.exit(1)
    with open(path) as f:
        return yaml.safe_load(f)


def _load_providers(load_order: list[str]) -> OrderedDict:
    providers: OrderedDict = OrderedDict()
    for pid in load_order:
        path = TEMPLATES_DIR / f"{pid}.yaml"
        if not path.exists():
            print(_yellow(f"  Warning: template {path.name} not found, skipping"))
            continue
        with open(path) as f:
            data = yaml.safe_load(f)
        # Normalise optional fields
        data.setdefault("env_vars", [])
        data.setdefault("extra_models", [])
        data.setdefault("tiers", {})
        providers[pid] = data
    return providers


# ── Config generation ──────────────────────────────────────────────────────

def _model_entry(m: dict) -> dict:
    """Build a model_list entry from a template model dict."""
    entry = {"model_name": m["model_name"]}
    if m.get("model_info"):
        entry["model_info"] = dict(m["model_info"])
    params = {"model": m["model"], "timeout": m.get("timeout", 600)}
    for key in ("api_key", "api_base"):
        if key in m:
            params[key] = m[key]
    if "thinking" in m:
        params["thinking"] = dict(m["thinking"])
    entry["litellm_params"] = params
    return entry


def _collect_models(selected_providers: list[str], providers: OrderedDict, tiers: list[str]) -> list[dict]:
    """Collect all model_list entries for selected providers, deduped."""
    seen_names: set[str] = set()
    models: list[dict] = []
    for pid in selected_providers:
        prov = providers[pid]
        for tier in tiers:
            for m in prov["tiers"].get(tier, []):
                if m["model_name"] not in seen_names:
                    seen_names.add(m["model_name"])
                    models.append(_model_entry(m))
        for m in prov.get("extra_models", []):
            if m["model_name"] not in seen_names:
                seen_names.add(m["model_name"])
                models.append(_model_entry(m))
    return models


def _build_fallbacks(
    primary_tiers: list[str],
    primary_provider: str,
    fallback_providers: list[str],
    fallback_order: dict[str, list[str]],
    providers: OrderedDict,
) -> list[dict]:
    """Build the fallback chain list for router_settings."""
    fallbacks: list[dict] = []
    prov = providers[primary_provider]
    for tier in primary_tiers:
        tier_models = prov["tiers"].get(tier, [])
        if not tier_models:
            continue
        primary_name = tier_models[0]["model_name"]
        chain: list[str] = []
        for fpid in fallback_order.get(tier, []):
            if fpid not in fallback_providers:
                continue
            fp = providers[fpid]
            for m in fp["tiers"].get(tier, []):
                if m["model_name"] != primary_name and m["model_name"] not in chain:
                    chain.append(m["model_name"])
        if chain:
            fallbacks.append({primary_name: chain})
    return fallbacks


def _generate_yaml(models: list[dict], fallbacks: list[dict], defaults: dict) -> str:
    """Render config.yaml as a clean YAML string."""
    lines: list[str] = ["model_list:"]

    for entry in models:
        lines.append(f"  - model_name: {entry['model_name']}")
        if "model_info" in entry:
            lines.append("    model_info:")
            for k, v in entry["model_info"].items():
                lines.append(f"      {k}: {v}")
        lines.append("    litellm_params:")
        params = entry["litellm_params"]
        for k, v in params.items():
            if isinstance(v, dict):
                lines.append(f"      {k}:")
                for sk, sv in v.items():
                    lines.append(f"        {sk}: {sv}")
            else:
                lines.append(f"      {k}: {v}")

    rs = defaults.get("router_settings", {})
    lines.append("")
    lines.append("router_settings:")
    for k, v in rs.items():
        lines.append(f"  {k}: {v}")

    if fallbacks:
        lines.append("  fallbacks:")
        for fb in fallbacks:
            for primary, chain in fb.items():
                lines.append(f"    - {primary}:")
                lines.append("        [")
                for m in chain:
                    lines.append(f"          {m},")
                lines.append("        ]")

    ls = defaults.get("litellm_settings", {})
    lines.append("")
    lines.append("litellm_settings:")
    for k, v in ls.items():
        lines.append(f"  {k}: {v}")

    gs = defaults.get("general_settings", {})
    lines.append("")
    lines.append("general_settings:")
    for k, v in gs.items():
        lines.append(f"  {k}: {v}")

    lines.append("")
    lines.append("environment_variables:")
    lines.append("  # Token dirs & auth files are set in .env (machine-specific paths)")
    lines.append("")

    return "\n".join(lines)


# ── Interactive wizard ─────────────────────────────────────────────────────

def run_wizard():
    defaults = _load_defaults()
    tiers = defaults.get("tiers", ["opus", "sonnet", "haiku"])
    load_order = defaults.get("load_order", [])
    default_tier_order = defaults.get("fallback_order", {})

    providers = _load_providers(load_order)
    if not providers:
        print(_red("No provider templates found in templates/"))
        sys.exit(1)

    print()
    print(_bold("litellmctl config wizard"))
    print(_dim("=" * 50))

    # ── Step 1: Primary provider & tiers ──
    primaries = [(pid, p) for pid, p in providers.items() if p.get("role") == "primary"]
    if len(primaries) == 1:
        primary_id, primary = primaries[0]
        print(f"\n  Primary provider: {_bold(primary['name'])}")
    else:
        print(f"\n{_bold('Primary providers:')}")
        for i, (pid, p) in enumerate(primaries, 1):
            print(f"  [{i}] {p['name']:<30} {_dim(p.get('desc', ''))}")
        idx = _pick_numbers("\nSelect primary provider [1]: ", len(primaries), "1")
        primary_id, primary = primaries[idx[0] if idx else 0]

    available_tiers = [t for t in tiers if t in primary["tiers"]]
    print(f"\n{_bold('Which tiers to expose?')}")
    for i, t in enumerate(available_tiers, 1):
        model_name = primary["tiers"][t][0]["model_name"]
        print(f"  [{i}] {t:<10} -> {model_name}")
    tier_idx = _pick_numbers(
        f"\nSelect tiers (comma-separated, or 'all') [all]: ",
        len(available_tiers),
    )
    selected_tiers = [available_tiers[i] for i in tier_idx] if tier_idx else available_tiers
    print(f"  -> {_green(', '.join(selected_tiers))}")

    # ── Step 2: Fallback providers ──
    fallbacks_list = [(pid, p) for pid, p in providers.items() if p.get("role") == "fallback"]
    print(f"\n{_bold('Available fallback providers:')}")
    for i, (pid, p) in enumerate(fallbacks_list, 1):
        auth_label = "OAuth" if p.get("auth") == "oauth" else "API key"
        tiers_avail = ", ".join(t for t in tiers if t in p["tiers"])
        print(f"  [{i}] {p['name']:<28} {auth_label:<10} {_dim(p.get('desc', ''))}")
        print(f"      {_dim('Tiers: ' + tiers_avail)}")

    fb_idx = _pick_numbers(
        f"\nSelect fallback providers (comma-separated, or 'all') [all]: ",
        len(fallbacks_list),
    )
    selected_fb_ids = (
        [fallbacks_list[i][0] for i in fb_idx]
        if fb_idx is not None
        else [pid for pid, _ in fallbacks_list]
    )
    selected_fb_names = [providers[pid]["name"] for pid in selected_fb_ids]
    print(f"  -> {_green(', '.join(selected_fb_names))}")

    # ── Step 3: Fallback ordering per tier ──
    fallback_order: dict[str, list[str]] = {}
    print(f"\n{_bold('Fallback order per tier')}")
    print(_dim("  (enter reordered numbers, or press Enter to accept default)"))

    for tier in selected_tiers:
        default_for_tier = default_tier_order.get(tier, [])
        available_for_tier = [
            pid for pid in default_for_tier
            if pid in selected_fb_ids and tier in providers[pid]["tiers"]
        ]
        for pid in selected_fb_ids:
            if pid not in available_for_tier and tier in providers[pid]["tiers"]:
                available_for_tier.append(pid)

        if not available_for_tier:
            fallback_order[tier] = []
            continue

        print(f"\n  {_bold(tier)}:")
        for i, pid in enumerate(available_for_tier, 1):
            m = providers[pid]["tiers"][tier][0]
            print(f"    [{i}] {m['model_name']:<40} ({providers[pid]['name']})")

        default_nums = ",".join(str(i) for i in range(1, len(available_for_tier) + 1))
        ans = _ask(f"  Order [{default_nums}]: ", default_nums)

        order: list[str] = []
        for part in ans.replace(" ", ",").split(","):
            part = part.strip()
            if part.isdigit() and 1 <= int(part) <= len(available_for_tier):
                pid = available_for_tier[int(part) - 1]
                if pid not in order:
                    order.append(pid)
        fallback_order[tier] = order if order else available_for_tier

    # ── Step 4: Generate ──
    all_selected = [primary_id] + selected_fb_ids
    models = _collect_models(all_selected, providers, tiers)
    fallbacks = _build_fallbacks(selected_tiers, primary_id, selected_fb_ids, fallback_order, providers)
    yaml_content = _generate_yaml(models, fallbacks, defaults)

    # Summary
    print(f"\n{_bold('Summary')}")
    print(_dim("-" * 50))
    print(f"  Primary:   {primary['name']} ({', '.join(selected_tiers)})")
    print(f"  Fallbacks: {', '.join(selected_fb_names)}")
    print(f"  Models:    {len(models)} total")

    env_vars_needed: list[str] = []
    auth_cmds_needed: list[str] = []
    for pid in all_selected:
        p = providers[pid]
        env_vars_needed.extend(p.get("env_vars", []))
        if p.get("auth_cmd"):
            auth_cmds_needed.append(p["auth_cmd"])
    env_vars_needed.append("LITELLM_MASTER_KEY")

    if env_vars_needed:
        print(f"\n  {_bold('Required .env vars:')} {', '.join(sorted(set(env_vars_needed)))}")
    if auth_cmds_needed:
        print(f"  {_bold('Auth commands:')}")
        for cmd in auth_cmds_needed:
            print(f"    {cmd}")
    print()

    ans = _ask("  Write config.yaml? [Y/n]: ", "y")
    if ans.lower().startswith("n"):
        print(_yellow("  Aborted."))
        return

    if CONFIG_FILE.exists():
        backup = CONFIG_FILE.with_suffix(".yaml.bak")
        shutil.copy2(CONFIG_FILE, backup)
        print(_dim(f"  Backed up -> {backup.name}"))

    CONFIG_FILE.write_text(yaml_content)
    print(_green(f"  Written to {CONFIG_FILE}"))
    print()


# ── CLI ────────────────────────────────────────────────────────────────────

if __name__ == "__main__":
    try:
        run_wizard()
    except KeyboardInterrupt:
        print(_yellow("\nAborted."))
        sys.exit(130)
    except Exception as e:
        print(_red(f"\nError: {e}"))
        sys.exit(1)
