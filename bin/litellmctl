#!/usr/bin/env bash
#
# litellmctl — LiteLLM proxy control CLI.
#
# Usage:
#   litellmctl <command> [args...]
#   litellmctl install              Run the installer
#   litellmctl auth status          Show auth token status
#   litellmctl start                Start proxy as background service
#   litellmctl stop                 Stop the proxy service
#   litellmctl restart              Restart the proxy service
#   litellmctl logs                 Tail proxy logs
#   litellmctl proxy                Start proxy in foreground (debug)
#   litellmctl help                 Show this help
#
# Tab completion:
#   litellmctl setup-completions
#

set -euo pipefail

BIN_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_DIR="$(cd "$BIN_DIR/.." && pwd)"
VENV_DIR="$PROJECT_DIR/venv"
PORT_FILE="$PROJECT_DIR/.proxy-port"
LOG_DIR="$PROJECT_DIR/logs"

# Service identifiers
LAUNCHD_LABEL="com.litellm.proxy"
LAUNCHD_PLIST="$HOME/Library/LaunchAgents/${LAUNCHD_LABEL}.plist"
SYSTEMD_UNIT="litellm-proxy"
SYSTEMD_DIR="$HOME/.config/systemd/user"
SYSTEMD_FILE="$SYSTEMD_DIR/${SYSTEMD_UNIT}.service"

# ── Completions ─────────────────────────────────────────────────────────────

generate_completions() {
  cat <<'COMP'
_litellmctl_completions() {
  local cur prev commands auth_cmds
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"

  commands="auth install start stop restart logs proxy status toggle-claude setup-completions help"
  auth_cmds="chatgpt gemini codex status refresh"

  case "$prev" in
    litellmctl)
      COMPREPLY=( $(compgen -W "$commands" -- "$cur") )
      return ;;
    auth)
      COMPREPLY=( $(compgen -W "$auth_cmds" -- "$cur") )
      return ;;
    refresh)
      COMPREPLY=( $(compgen -W "chatgpt gemini" -- "$cur") )
      return ;;
    start|proxy)
      COMPREPLY=( $(compgen -W "--port --config" -- "$cur") )
      return ;;
  esac
}
complete -F _litellmctl_completions litellmctl
COMP
}

generate_zsh_completions() {
  cat <<'COMP'
_litellmctl_completions() {
  local -a commands auth_cmds
  commands=(
    'auth:Manage OAuth tokens'
    'install:Install/reinstall LiteLLM'
    'start:Start proxy as background service'
    'stop:Stop the proxy service'
    'restart:Restart the proxy service'
    'logs:Tail proxy logs'
    'proxy:Start proxy in foreground (debug)'
    'status:Show auth + proxy status'
    'toggle-claude:Toggle Claude Code between direct API and proxy'
    'setup-completions:Add litellmctl to your shell'
    'help:Show help'
  )
  auth_cmds=(
    'chatgpt:Login to ChatGPT/Codex'
    'gemini:Login to Gemini CLI'
    'codex:Login to ChatGPT/Codex'
    'status:Show token status'
    'refresh:Refresh existing token'
  )

  if (( CURRENT == 2 )); then
    _describe 'command' commands
  elif (( CURRENT == 3 )); then
    case "${words[2]}" in
      auth)    _describe 'auth command' auth_cmds ;;
      refresh) compadd chatgpt gemini ;;
      start|proxy) compadd -- --port --config ;;
    esac
  elif (( CURRENT == 4 )); then
    case "${words[3]}" in
      refresh) compadd chatgpt gemini ;;
    esac
  fi
}
compdef _litellmctl_completions litellmctl
COMP
}

# ── Helpers ─────────────────────────────────────────────────────────────────

info()  { printf "\033[1;34m==> %s\033[0m\n" "$*"; }
warn()  { printf "\033[1;33m==> %s\033[0m\n" "$*"; }
error() { printf "\033[1;31m==> %s\033[0m\n" "$*" >&2; }

activate_venv() {
  if [ ! -d "$VENV_DIR" ]; then
    error "No virtualenv found. Run 'litellmctl install' first."
    exit 1
  fi
  # shellcheck disable=SC1091
  source "$VENV_DIR/bin/activate"
}

load_env() {
  if [ -f "$PROJECT_DIR/.env" ]; then
    set -a
    # shellcheck disable=SC1091
    source "$PROJECT_DIR/.env"
    set +a
  fi
}

get_proxy_port() {
  if [ -f "$PORT_FILE" ]; then
    cat "$PORT_FILE"
  else
    echo "4000"
  fi
}

find_proxy_pid() {
  local port
  port=$(get_proxy_port)
  lsof -i :"$port" -t 2>/dev/null | head -1 || true
}

is_macos() { [[ "$(uname -s)" == "Darwin" ]]; }
is_linux() { [[ "$(uname -s)" == "Linux" ]]; }

ensure_log_dir() {
  mkdir -p "$LOG_DIR"
}

# ── Service: macOS launchd ──────────────────────────────────────────────────

launchd_install() {
  local port="$1"
  local config="$2"

  ensure_log_dir
  mkdir -p "$(dirname "$LAUNCHD_PLIST")"

  local env_block=""
  if [ -f "$PROJECT_DIR/.env" ]; then
    while IFS='=' read -r key value; do
      [[ "$key" =~ ^[[:space:]]*# ]] && continue
      [[ -z "$key" ]] && continue
      env_block="${env_block}    <key>${key}</key>
    <string>${value}</string>
"
    done < "$PROJECT_DIR/.env"
  fi

  cat > "$LAUNCHD_PLIST" <<PLIST
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>${LAUNCHD_LABEL}</string>
  <key>ProgramArguments</key>
  <array>
    <string>${VENV_DIR}/bin/litellm</string>
    <string>--config</string>
    <string>${config}</string>
    <string>--port</string>
    <string>${port}</string>
  </array>
  <key>WorkingDirectory</key>
  <string>${PROJECT_DIR}</string>
  <key>EnvironmentVariables</key>
  <dict>
    <key>PATH</key>
    <string>${VENV_DIR}/bin:/usr/local/bin:/usr/bin:/bin</string>
    <key>VIRTUAL_ENV</key>
    <string>${VENV_DIR}</string>
${env_block}  </dict>
  <key>RunAtLoad</key>
  <true/>
  <key>KeepAlive</key>
  <true/>
  <key>StandardOutPath</key>
  <string>${LOG_DIR}/proxy.log</string>
  <key>StandardErrorPath</key>
  <string>${LOG_DIR}/proxy-error.log</string>
</dict>
</plist>
PLIST

  echo "$port" > "$PORT_FILE"

  launchctl bootout "gui/$(id -u)/${LAUNCHD_LABEL}" 2>/dev/null || true
  launchctl bootstrap "gui/$(id -u)" "$LAUNCHD_PLIST"

  info "Installed launchd service ($LAUNCHD_LABEL)"
  info "Proxy starting on port $port (auto-starts on login)"
  info "Logs: $LOG_DIR/proxy.log"
}

launchd_stop() {
  launchctl bootout "gui/$(id -u)/${LAUNCHD_LABEL}" 2>/dev/null && \
    info "Service stopped." || warn "Service not running."
}

launchd_is_running() {
  launchctl print "gui/$(id -u)/${LAUNCHD_LABEL}" &>/dev/null
}

launchd_uninstall() {
  launchctl bootout "gui/$(id -u)/${LAUNCHD_LABEL}" 2>/dev/null || true
  rm -f "$LAUNCHD_PLIST"
  info "Removed launchd service."
}

# ── Service: Linux systemd ──────────────────────────────────────────────────

systemd_install() {
  local port="$1"
  local config="$2"

  ensure_log_dir
  mkdir -p "$SYSTEMD_DIR"

  local env_lines=""
  if [ -f "$PROJECT_DIR/.env" ]; then
    while IFS= read -r line; do
      [[ "$line" =~ ^[[:space:]]*# ]] && continue
      [[ -z "$line" ]] && continue
      env_lines="${env_lines}Environment=${line}"$'\n'
    done < "$PROJECT_DIR/.env"
  fi

  cat > "$SYSTEMD_FILE" <<UNIT
[Unit]
Description=LiteLLM Proxy
After=network.target

[Service]
Type=simple
WorkingDirectory=${PROJECT_DIR}
ExecStart=${VENV_DIR}/bin/litellm --config ${config} --port ${port}
Restart=on-failure
RestartSec=5

Environment=PATH=${VENV_DIR}/bin:/usr/local/bin:/usr/bin:/bin
Environment=VIRTUAL_ENV=${VENV_DIR}
${env_lines}
StandardOutput=append:${LOG_DIR}/proxy.log
StandardError=append:${LOG_DIR}/proxy-error.log

[Install]
WantedBy=default.target
UNIT

  echo "$port" > "$PORT_FILE"

  systemctl --user daemon-reload
  systemctl --user enable "$SYSTEMD_UNIT"
  systemctl --user start "$SYSTEMD_UNIT"

  info "Installed systemd user service ($SYSTEMD_UNIT)"
  info "Proxy starting on port $port (auto-starts on login)"
  info "Logs: $LOG_DIR/proxy.log"
}

systemd_stop() {
  systemctl --user stop "$SYSTEMD_UNIT" 2>/dev/null && \
    info "Service stopped." || warn "Service not running."
}

systemd_is_running() {
  systemctl --user is-active "$SYSTEMD_UNIT" &>/dev/null
}

systemd_uninstall() {
  systemctl --user stop "$SYSTEMD_UNIT" 2>/dev/null || true
  systemctl --user disable "$SYSTEMD_UNIT" 2>/dev/null || true
  rm -f "$SYSTEMD_FILE"
  systemctl --user daemon-reload
  info "Removed systemd service."
}

# ── Commands ────────────────────────────────────────────────────────────────

cmd_setup_completions() {
  local shell_name rc_file

  shell_name="$(basename "${SHELL:-/bin/bash}")"
  case "$shell_name" in
    zsh)  rc_file="$HOME/.zshrc" ;;
    *)    rc_file="$HOME/.bashrc" ;;
  esac

  if grep -qF "alias litellmctl=" "$rc_file" 2>/dev/null; then
    info "litellmctl already set up in $rc_file"
    return
  fi

  local block
  if [ "$shell_name" = "zsh" ]; then
    block='
# LiteLLM CLI
alias litellmctl="~/.litellm/bin/litellmctl"
eval "$(~/.litellm/bin/litellmctl --zsh-completions)"'
  else
    block='
# LiteLLM CLI
alias litellmctl="~/.litellm/bin/litellmctl"
eval "$(~/.litellm/bin/litellmctl --completions)"'
  fi

  printf '%s\n' "$block" >> "$rc_file"
  info "Added litellmctl alias + tab completion to $rc_file"
  info "Run: source $rc_file  (or open a new terminal)"
}

cmd_install() {
  exec "$BIN_DIR/install" "$@"
}

cmd_auth() {
  activate_venv
  load_env
  exec python3 "$BIN_DIR/auth" "$@"
}

cmd_start() {
  local port=4000
  local config="$PROJECT_DIR/config.yaml"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --port)   port="$2"; shift 2 ;;
      --config) config="$2"; shift 2 ;;
      *)        shift ;;
    esac
  done

  local stale_pid
  stale_pid=$(lsof -i :"$port" -t 2>/dev/null | head -1 || true)
  if [ -n "$stale_pid" ]; then
    warn "Killing stale process $stale_pid on port $port"
    kill -9 "$stale_pid" 2>/dev/null || true
    sleep 1
  fi

  if is_macos; then
    launchd_install "$port" "$config"
  elif is_linux; then
    systemd_install "$port" "$config"
  else
    error "Unsupported OS. Use 'litellmctl proxy' for foreground mode."
    exit 1
  fi
}

cmd_stop() {
  if is_macos; then
    launchd_stop
  elif is_linux; then
    systemd_stop
  else
    local port pid
    port=$(get_proxy_port)
    pid=$(find_proxy_pid)
    if [ -n "$pid" ]; then
      kill "$pid" 2>/dev/null
      info "Stopped (PID $pid)."
    else
      warn "No proxy found."
    fi
  fi
}

cmd_restart() {
  info "Restarting proxy ..."
  if is_macos; then
    launchd_stop
    sleep 1
    local port config
    port=$(get_proxy_port)
    config="$PROJECT_DIR/config.yaml"
    launchd_install "$port" "$config"
  elif is_linux; then
    systemctl --user restart "$SYSTEMD_UNIT"
    info "Restarted."
  else
    cmd_stop
    sleep 1
    cmd_start
  fi
}

cmd_logs() {
  ensure_log_dir
  local logfile="$LOG_DIR/proxy.log"
  local errfile="$LOG_DIR/proxy-error.log"

  if [ ! -f "$logfile" ] && [ ! -f "$errfile" ]; then
    warn "No log files found yet. Start the proxy first with 'litellmctl start'."
    exit 0
  fi

  info "Tailing $LOG_DIR  (Ctrl+C to stop)"
  tail -f "$logfile" "$errfile" 2>/dev/null
}

cmd_proxy() {
  activate_venv
  load_env
  unset DEBUG 2>/dev/null || true

  local port=4000
  local config="$PROJECT_DIR/config.yaml"
  local extra_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --port)   port="$2"; shift 2 ;;
      --config) config="$2"; shift 2 ;;
      *)        extra_args+=("$1"); shift ;;
    esac
  done

  local stale_pid
  stale_pid=$(lsof -i :"$port" -t 2>/dev/null | head -1 || true)
  if [ -n "$stale_pid" ]; then
    warn "Killing stale process $stale_pid on port $port"
    kill -9 "$stale_pid" 2>/dev/null || true
    sleep 1
  fi

  echo "$port" > "$PORT_FILE"

  info "Starting LiteLLM proxy on port $port (foreground) ..."
  if [ ${#extra_args[@]} -gt 0 ]; then
    exec litellm --config "$config" --port "$port" "${extra_args[@]}"
  else
    exec litellm --config "$config" --port "$port"
  fi
}

cmd_uninstall_service() {
  if is_macos; then
    launchd_uninstall
  elif is_linux; then
    systemd_uninstall
  fi
}

cmd_status() {
  activate_venv
  load_env
  python3 "$BIN_DIR/auth" status

  local port pid
  port=$(get_proxy_port)

  printf "\033[1mProxy\033[0m\n"

  if is_macos && launchd_is_running; then
    pid=$(find_proxy_pid)
    printf "  Service: \033[32mrunning\033[0m (launchd, auto-start enabled)\n"
    printf "  Port:    %s\n" "$port"
    [ -n "$pid" ] && printf "  PID:     %s\n" "$pid"
    printf "\n"
  elif is_linux && systemd_is_running; then
    pid=$(find_proxy_pid)
    printf "  Service: \033[32mrunning\033[0m (systemd, auto-start enabled)\n"
    printf "  Port:    %s\n" "$port"
    [ -n "$pid" ] && printf "  PID:     %s\n" "$pid"
    printf "\n"
  else
    pid=$(find_proxy_pid)
    if [ -n "$pid" ]; then
      printf "  PID %s running on port %s (foreground)\n\n" "$pid" "$port"
    else
      printf "  \033[33mNot running\033[0m\n\n"
    fi
  fi
}

show_help() {
  cat <<EOF

$(printf "\033[1mlitellmctl — LiteLLM Proxy Control\033[0m")

$(printf "\033[1mUsage:\033[0m")  litellmctl <command> [args...]

$(printf "\033[1mCommands:\033[0m")
  install              Install / reinstall LiteLLM fork
  auth chatgpt         Login to ChatGPT / Codex (browser PKCE)
  auth gemini          Login to Gemini CLI (browser PKCE)
  auth refresh <p>     Refresh token for <chatgpt|gemini>
  auth status          Show auth token status
  start [--port N]     Start proxy as background service (auto-start on boot)
  stop                 Stop the proxy service
  restart              Restart the proxy service
  logs                 Tail proxy logs
  proxy [--port N]     Start proxy in foreground (for debugging)
  uninstall-service    Remove the system service
  status               Show auth + proxy status
  toggle-claude        Toggle Claude Code between direct API and proxy
  setup-completions    Add litellmctl to your shell
  help                 Show this help

$(printf "\033[1mService:\033[0m")
  macOS: launchd agent (~/Library/LaunchAgents/)
  Linux: systemd user unit (~/.config/systemd/user/)

EOF
}

# ── Main ────────────────────────────────────────────────────────────────────

if [[ $# -eq 0 ]]; then
  show_help
  exit 0
fi

case "$1" in
  --completions)     generate_completions; exit 0 ;;
  --zsh-completions) generate_zsh_completions; exit 0 ;;
  install)           shift; cmd_install "$@" ;;
  auth)              shift; cmd_auth "$@" ;;
  start)             shift; cmd_start "$@" ;;
  stop)              shift; cmd_stop ;;
  restart)           shift; cmd_restart ;;
  logs)              shift; cmd_logs ;;
  proxy)             shift; cmd_proxy "$@" ;;
  uninstall-service) shift; cmd_uninstall_service ;;
  setup-completions) shift; cmd_setup_completions ;;
  status)            shift; cmd_status "$@" ;;
  toggle-claude)     exec "$BIN_DIR/toggle-claude" ;;
  help|-h|--help)    show_help ;;
  *)                 error "Unknown command: $1"; show_help; exit 1 ;;
esac
