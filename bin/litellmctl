#!/usr/bin/env bash
#
# litellmctl — LiteLLM proxy control CLI.
#
# Usage:
#   litellmctl <command> [args...]
#   litellmctl install              Install, update, or rebuild LiteLLM
#   litellmctl auth status          Show auth token status
#   litellmctl start                Start proxy as background service
#   litellmctl stop                 Stop the proxy service
#   litellmctl restart | r          Restart the proxy service
#   litellmctl logs                 Tail proxy logs
#   litellmctl proxy                Start proxy in foreground (debug)
#   litellmctl help                 Show this help
#
# Tab completion:
#   litellmctl setup-completions
#

set -euo pipefail

BIN_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_DIR="$(cd "$BIN_DIR/.." && pwd)"

# If running from a symlink outside ~/.litellm, resolve to canonical path
if [ ! -f "$PROJECT_DIR/config.yaml" ]; then
  PROJECT_DIR="$HOME/.litellm"
fi
VENV_DIR="$PROJECT_DIR/venv"
PORT_FILE="$PROJECT_DIR/.proxy-port"
LOG_DIR="$PROJECT_DIR/logs"

# Service identifiers
LAUNCHD_LABEL="com.litellm.proxy"
LAUNCHD_PLIST="$HOME/Library/LaunchAgents/${LAUNCHD_LABEL}.plist"
SYSTEMD_UNIT="litellm-proxy"
SYSTEMD_DIR="$HOME/.config/systemd/user"
SYSTEMD_FILE="$SYSTEMD_DIR/${SYSTEMD_UNIT}.service"

# ── Completions ─────────────────────────────────────────────────────────────

generate_completions() {
  cat <<'COMP'
_litellmctl_completions() {
  local cur prev commands auth_cmds
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"

  commands="auth wizard install init-env start stop restart r logs proxy status toggle-claude setup-completions help"
  auth_cmds="chatgpt gemini qwen kimi codex status refresh export import"

  case "$prev" in
    litellmctl)
      COMPREPLY=( $(compgen -W "$commands" -- "$cur") )
      return ;;
    auth)
      COMPREPLY=( $(compgen -W "$auth_cmds" -- "$cur") )
      return ;;
    refresh|export)
      COMPREPLY=( $(compgen -W "chatgpt gemini qwen kimi" -- "$cur") )
      return ;;
    start|proxy)
      COMPREPLY=( $(compgen -W "--port --config" -- "$cur") )
      return ;;
  esac
}
complete -F _litellmctl_completions litellmctl
COMP
}

generate_zsh_completions() {
  cat <<'COMP'
_litellmctl_completions() {
  local -a commands auth_cmds
  commands=(
    'auth:Manage OAuth tokens'
    'wizard:Interactive config.yaml generator'
    'install:Install, update, or rebuild LiteLLM'
    'init-env:Detect auth files and update .env paths'
    'start:Start proxy as background service'
    'stop:Stop the proxy service'
    'restart:Restart the proxy service'
    'r:Alias for restart'
    'logs:Tail proxy logs'
    'proxy:Start proxy in foreground (debug)'
    'status:Show auth + proxy status'
    'toggle-claude:Toggle Claude Code between direct API and proxy'
    'setup-completions:Add litellmctl to your shell'
    'help:Show help'
  )
  auth_cmds=(
    'chatgpt:Login to ChatGPT/Codex'
    'gemini:Login to Gemini CLI'
    'qwen:Login to Qwen Portal'
    'kimi:Login to Kimi Code'
    'codex:Login to ChatGPT/Codex'
    'status:Show token status'
    'refresh:Refresh existing token'
    'export:Copy credentials as transfer script'
    'import:Read credentials from stdin'
  )

  if (( CURRENT == 2 )); then
    _describe 'command' commands
  elif (( CURRENT == 3 )); then
    case "${words[2]}" in
      auth)    _describe 'auth command' auth_cmds ;;
      refresh|export) compadd chatgpt gemini qwen kimi ;;
      start|proxy) compadd -- --port --config ;;
    esac
  elif (( CURRENT == 4 )); then
    case "${words[3]}" in
      refresh|export) compadd chatgpt gemini qwen kimi ;;
    esac
  fi
}
compdef _litellmctl_completions litellmctl
COMP
}

# ── Helpers ─────────────────────────────────────────────────────────────────

info()  { printf "\033[1;34m==> %s\033[0m\n" "$*"; }
warn()  { printf "\033[1;33m==> %s\033[0m\n" "$*"; }
error() { printf "\033[1;31m==> %s\033[0m\n" "$*" >&2; }

activate_venv() {
  if [ ! -d "$VENV_DIR" ]; then
    error "No virtualenv found. Run 'litellmctl install' first."
    exit 1
  fi
  # shellcheck disable=SC1091
  source "$VENV_DIR/bin/activate"
}

load_env() {
  if [ -f "$PROJECT_DIR/.env" ]; then
    set -a
    # shellcheck disable=SC1091
    source "$PROJECT_DIR/.env"
    set +a
  fi
}

get_proxy_port() {
  if [ -f "$PORT_FILE" ]; then
    cat "$PORT_FILE"
  else
    echo "4000"
  fi
}

is_interactive() { [ -t 0 ]; }

# Portable PID lookup for a listening port — works on Linux without lsof.
_pids_on_port() {
  local port="$1"
  if command -v lsof &>/dev/null; then
    lsof -i :"$port" -t 2>/dev/null || true
  elif command -v ss &>/dev/null; then
    ss -tlnp "sport = :$port" 2>/dev/null \
      | grep -oP 'pid=\K[0-9]+' 2>/dev/null || true
  elif command -v fuser &>/dev/null; then
    fuser "$port/tcp" 2>/dev/null | tr -s ' ' '\n' | grep -E '^[0-9]+$' || true
  fi
}

find_proxy_pid() {
  local port
  port=$(get_proxy_port)
  _pids_on_port "$port" | head -1
}

kill_stale_on_port() {
  local port="$1"
  local pids
  pids=$(_pids_on_port "$port")
  if [ -n "$pids" ]; then
    local count
    count=$(echo "$pids" | wc -l | tr -d ' ')
    warn "Killing $count stale process(es) on port $port: $(echo $pids | tr '\n' ' ')"
    echo "$pids" | xargs kill -9 2>/dev/null || true
    sleep 1
  fi
}

is_macos() { [[ "$(uname -s)" == "Darwin" ]]; }
is_linux() { [[ "$(uname -s)" == "Linux" ]]; }

# Build extra CLI flags from env vars (NUM_WORKERS, KEEPALIVE_TIMEOUT).
_perf_flags() {
  local flags=()
  local workers="${NUM_WORKERS:-1}"
  if [ "$workers" -gt 1 ] 2>/dev/null; then
    flags+=(--num_workers "$workers")
  fi
  if [ -n "${KEEPALIVE_TIMEOUT:-}" ]; then
    flags+=(--keepalive_timeout "$KEEPALIVE_TIMEOUT")
  fi
  echo "${flags[@]}"
}

ensure_log_dir() {
  mkdir -p "$LOG_DIR"
}

# ── Service: macOS launchd ──────────────────────────────────────────────────

launchd_install() {
  local port="$1"
  local config="$2"

  ensure_log_dir
  mkdir -p "$(dirname "$LAUNCHD_PLIST")"

  local env_block=""
  if [ -f "$PROJECT_DIR/.env" ]; then
    while IFS='=' read -r key value; do
      [[ "$key" =~ ^[[:space:]]*# ]] && continue
      [[ -z "$key" ]] && continue
      env_block="${env_block}    <key>${key}</key>
    <string>${value}</string>
"
    done < "$PROJECT_DIR/.env"
  fi

  local perf_args=""
  local workers="${NUM_WORKERS:-1}"
  if [ "$workers" -gt 1 ] 2>/dev/null; then
    perf_args="${perf_args}    <string>--num_workers</string>
    <string>${workers}</string>
"
  fi
  if [ -n "${KEEPALIVE_TIMEOUT:-}" ]; then
    perf_args="${perf_args}    <string>--keepalive_timeout</string>
    <string>${KEEPALIVE_TIMEOUT}</string>
"
  fi

  cat > "$LAUNCHD_PLIST" <<PLIST
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>${LAUNCHD_LABEL}</string>
  <key>ProgramArguments</key>
  <array>
    <string>${VENV_DIR}/bin/litellm</string>
    <string>--config</string>
    <string>${config}</string>
    <string>--port</string>
    <string>${port}</string>
${perf_args}  </array>
  <key>WorkingDirectory</key>
  <string>${PROJECT_DIR}</string>
  <key>EnvironmentVariables</key>
  <dict>
    <key>PATH</key>
    <string>${VENV_DIR}/bin:/usr/local/bin:/usr/bin:/bin</string>
    <key>VIRTUAL_ENV</key>
    <string>${VENV_DIR}</string>
${env_block}  </dict>
  <key>RunAtLoad</key>
  <true/>
  <key>KeepAlive</key>
  <true/>
  <key>StandardOutPath</key>
  <string>${LOG_DIR}/proxy.log</string>
  <key>StandardErrorPath</key>
  <string>${LOG_DIR}/proxy-error.log</string>
</dict>
</plist>
PLIST

  echo "$port" > "$PORT_FILE"

  launchctl bootout "gui/$(id -u)/${LAUNCHD_LABEL}" 2>/dev/null || true
  launchctl bootstrap "gui/$(id -u)" "$LAUNCHD_PLIST"

  info "Installed launchd service ($LAUNCHD_LABEL)"
  info "Proxy starting on port $port (auto-starts on login)"
  info "Logs: $LOG_DIR/proxy.log"
}

launchd_stop() {
  launchctl bootout "gui/$(id -u)/${LAUNCHD_LABEL}" 2>/dev/null && \
    info "Service stopped." || warn "Service not running."
}

launchd_is_running() {
  launchctl print "gui/$(id -u)/${LAUNCHD_LABEL}" &>/dev/null
}

launchd_uninstall() {
  launchctl bootout "gui/$(id -u)/${LAUNCHD_LABEL}" 2>/dev/null || true
  rm -f "$LAUNCHD_PLIST"
  info "Removed launchd service."
}

# ── Service: Linux systemd ──────────────────────────────────────────────────

systemd_install() {
  local port="$1"
  local config="$2"

  ensure_log_dir
  mkdir -p "$SYSTEMD_DIR"

  local env_lines=""
  if [ -f "$PROJECT_DIR/.env" ]; then
    while IFS= read -r line; do
      [[ "$line" =~ ^[[:space:]]*# ]] && continue
      [[ -z "$line" ]] && continue
      env_lines="${env_lines}Environment=${line}"$'\n'
    done < "$PROJECT_DIR/.env"
  fi

  cat > "$SYSTEMD_FILE" <<UNIT
[Unit]
Description=LiteLLM Proxy
After=network.target

[Service]
Type=simple
WorkingDirectory=${PROJECT_DIR}
ExecStart=${VENV_DIR}/bin/litellm --config ${config} --port ${port} $(_perf_flags)
Restart=on-failure
RestartSec=5

Environment=PATH=${VENV_DIR}/bin:/usr/local/bin:/usr/bin:/bin
Environment=VIRTUAL_ENV=${VENV_DIR}
${env_lines}
StandardOutput=append:${LOG_DIR}/proxy.log
StandardError=append:${LOG_DIR}/proxy-error.log

[Install]
WantedBy=default.target
UNIT

  echo "$port" > "$PORT_FILE"

  systemctl --user daemon-reload
  systemctl --user enable "$SYSTEMD_UNIT"
  systemctl --user start "$SYSTEMD_UNIT"

  info "Installed systemd user service ($SYSTEMD_UNIT)"
  info "Proxy starting on port $port (auto-starts on login)"
  info "Logs: $LOG_DIR/proxy.log"

  # Enable lingering so the service survives logout (requires loginctl).
  if command -v loginctl &>/dev/null; then
    if ! loginctl show-user "$USER" --property=Linger 2>/dev/null | grep -q "yes"; then
      warn "Enabling loginctl linger for $USER (keeps service running after logout)"
      loginctl enable-linger "$USER" 2>/dev/null || true
    fi
  fi
}

systemd_stop() {
  systemctl --user stop "$SYSTEMD_UNIT" 2>/dev/null && \
    info "Service stopped." || warn "Service not running."
}

systemd_is_running() {
  systemctl --user is-active "$SYSTEMD_UNIT" &>/dev/null
}

systemd_uninstall() {
  systemctl --user stop "$SYSTEMD_UNIT" 2>/dev/null || true
  systemctl --user disable "$SYSTEMD_UNIT" 2>/dev/null || true
  rm -f "$SYSTEMD_FILE"
  systemctl --user daemon-reload
  info "Removed systemd service."
}

has_systemd_user() {
  # systemctl --user requires a dbus session bus and XDG_RUNTIME_DIR.
  # Without these, the command hangs on headless Linux / SSH / containers.
  [ -n "${XDG_RUNTIME_DIR:-}" ] || return 1
  command -v systemctl &>/dev/null || return 1
  local bin
  bin="$(type -P timeout 2>/dev/null || true)"
  if [ -n "$bin" ]; then
    "$bin" -k 3 5 systemctl --user status >/dev/null 2>&1
  else
    systemctl --user status >/dev/null 2>&1
  fi
}

# ── Service: nohup fallback (servers without systemd user bus) ─────────────

PIDFILE="$PROJECT_DIR/.proxy.pid"

nohup_start() {
  local port="$1"
  local config="$2"

  ensure_log_dir
  activate_venv
  load_env

  echo "$port" > "$PORT_FILE"

  # shellcheck disable=SC2046
  nohup "$VENV_DIR/bin/litellm" --config "$config" --port "$port" $(_perf_flags) \
    >> "$LOG_DIR/proxy.log" 2>> "$LOG_DIR/proxy-error.log" &
  local pid=$!
  echo "$pid" > "$PIDFILE"
  disown "$pid" 2>/dev/null || true

  info "Proxy started in background (PID $pid, port $port)"
  info "Logs: $LOG_DIR/proxy.log"
  info "Note: add 'litellmctl start' to cron @reboot for auto-start"
}

nohup_stop() {
  local pid=""
  if [ -f "$PIDFILE" ]; then
    pid=$(cat "$PIDFILE")
  fi
  if [ -z "$pid" ]; then
    pid=$(find_proxy_pid)
  fi
  if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
    kill "$pid" 2>/dev/null
    rm -f "$PIDFILE"
    info "Stopped (PID $pid)."
  else
    rm -f "$PIDFILE"
    warn "No proxy found."
  fi
}

nohup_is_running() {
  if [ -f "$PIDFILE" ]; then
    local pid
    pid=$(cat "$PIDFILE")
    kill -0 "$pid" 2>/dev/null && return 0
  fi
  [ -n "$(find_proxy_pid)" ]
}

# ── Commands ────────────────────────────────────────────────────────────────

cmd_setup_completions() {
  local shell_name rc_file

  shell_name="$(basename "${SHELL:-/bin/bash}")"
  case "$shell_name" in
    zsh)  rc_file="$HOME/.zshrc" ;;
    *)    rc_file="$HOME/.bashrc" ;;
  esac

  if grep -qF "alias litellmctl=" "$rc_file" 2>/dev/null; then
    info "litellmctl already set up in $rc_file"
    return
  fi

  local block
  if [ "$shell_name" = "zsh" ]; then
    block='
# LiteLLM CLI
alias litellmctl="~/.litellm/bin/litellmctl"
eval "$(~/.litellm/bin/litellmctl --zsh-completions)"'
  else
    block='
# LiteLLM CLI
alias litellmctl="~/.litellm/bin/litellmctl"
eval "$(~/.litellm/bin/litellmctl --completions)"'
  fi

  printf '%s\n' "$block" >> "$rc_file"
  info "Added litellmctl alias + tab completion to $rc_file"
  info "Run: source $rc_file  (or open a new terminal)"
}

cmd_install() {
  "$BIN_DIR/install" "$@"

  # Ask to restart if service is running
  local running=false
  if is_macos && launchd_is_running; then running=true; fi
  if is_linux && systemd_is_running; then running=true; fi
  if nohup_is_running; then running=true; fi
  if [ -n "$(find_proxy_pid)" ]; then running=true; fi

  if $running; then
    if is_interactive; then
      printf "\n  Proxy is running. Restart now? [Y/n] "
      read -r answer </dev/tty || answer="n"
      case "$answer" in
        [nN]*) info "Skipped restart. Run 'litellmctl restart' when ready." ;;
        *)     cmd_restart ;;
      esac
    else
      info "Proxy is running. Run 'litellmctl restart' to apply changes."
    fi
  fi
}

cmd_auth() {
  activate_venv
  load_env
  exec python3 "$BIN_DIR/auth" "$@"
}

cmd_start() {
  load_env
  local port=4000
  local config="$PROJECT_DIR/config.yaml"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --port)   port="$2"; shift 2 ;;
      --config) config="$2"; shift 2 ;;
      *)        shift ;;
    esac
  done

  kill_stale_on_port "$port"

  if is_macos; then
    launchd_install "$port" "$config"
  elif is_linux && has_systemd_user; then
    systemd_install "$port" "$config"
  else
    nohup_start "$port" "$config"
  fi
}

cmd_stop() {
  local port
  port=$(get_proxy_port)
  if is_macos && launchd_is_running; then
    launchd_stop
  elif is_linux && systemd_is_running; then
    systemd_stop
  else
    nohup_stop
  fi
  kill_stale_on_port "$port"
}

cmd_restart() {
  load_env
  info "Restarting proxy ..."
  local port config
  port=$(get_proxy_port)
  config="$PROJECT_DIR/config.yaml"

  if is_macos && launchd_is_running; then
    launchd_stop
  elif is_linux && systemd_is_running; then
    systemctl --user stop "$SYSTEMD_UNIT" 2>/dev/null || true
  else
    nohup_stop
  fi

  sleep 1
  kill_stale_on_port "$port"

  if is_macos; then
    launchd_install "$port" "$config"
  elif is_linux && has_systemd_user; then
    systemctl --user daemon-reload
    systemctl --user start "$SYSTEMD_UNIT"
    info "Restarted."
  else
    nohup_start "$port" "$config"
  fi
}

cmd_logs() {
  ensure_log_dir
  local logfile="$LOG_DIR/proxy.log"
  local errfile="$LOG_DIR/proxy-error.log"

  if [ ! -f "$logfile" ] && [ ! -f "$errfile" ]; then
    warn "No log files found yet. Start the proxy first with 'litellmctl start'."
    exit 0
  fi

  info "Tailing $LOG_DIR  (Ctrl+C to stop)"
  tail -f "$logfile" "$errfile" 2>/dev/null
}

cmd_proxy() {
  activate_venv
  load_env
  unset DEBUG 2>/dev/null || true

  local port=4000
  local config="$PROJECT_DIR/config.yaml"
  local extra_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --port)   port="$2"; shift 2 ;;
      --config) config="$2"; shift 2 ;;
      *)        extra_args+=("$1"); shift ;;
    esac
  done

  kill_stale_on_port "$port"

  echo "$port" > "$PORT_FILE"

  info "Starting LiteLLM proxy on port $port (foreground) ..."
  # shellcheck disable=SC2046
  if [ ${#extra_args[@]} -gt 0 ]; then
    exec litellm --config "$config" --port "$port" $(_perf_flags) "${extra_args[@]}"
  else
    exec litellm --config "$config" --port "$port" $(_perf_flags)
  fi
}

cmd_init_env() {
  local env_file="$PROJECT_DIR/.env"
  local changed=0

  if [ ! -f "$env_file" ]; then
    warn "No .env file found. Copy .env.example first:"
    warn "  cp $PROJECT_DIR/.env.example $env_file"
    exit 1
  fi

  # Upsert a single key=value in .env. Only touches the target key;
  # all other lines (comments, blanks, other vars) are preserved as-is.
  _upsert_env_var() {
    local var="$1" val="$2"
    if grep -q "^${var}=" "$env_file" 2>/dev/null; then
      local old_val
      old_val=$(grep "^${var}=" "$env_file" | head -1 | cut -d= -f2-)
      if [ "$old_val" = "$val" ]; then
        return 1  # already correct
      fi
      sed -i.bak "s|^${var}=.*|${var}=${val}|" "$env_file"
      rm -f "$env_file.bak"
      changed=1
      printf "    \033[36m↻\033[0m %s: %s → %s\n" "$var" "$old_val" "$val"
      return 0
    else
      printf '\n%s=%s' "$var" "$val" >> "$env_file"
      # ensure trailing newline
      printf '\n' >> "$env_file"
      changed=1
      printf "    \033[32m+\033[0m %s=%s\n" "$var" "$val"
      return 0
    fi
  }

  _process_auth() {
    local auth_file="$1" dir_var="$2" file_var="$3"
    if [ -f "$PROJECT_DIR/$auth_file" ]; then
      local sub_changed=0
      _upsert_env_var "$dir_var" "$PROJECT_DIR" && sub_changed=1
      _upsert_env_var "$file_var" "$auth_file" && sub_changed=1
      if [ $sub_changed -eq 0 ]; then
        printf "  \033[32m✓\033[0m %-30s (up to date)\n" "$auth_file"
      else
        printf "  \033[32m✓\033[0m %-30s synced\n" "$auth_file"
      fi
    else
      printf "  \033[33m-\033[0m %-30s (not found, skipped)\n" "$auth_file"
    fi
  }

  info "Scanning $PROJECT_DIR for auth files ..."
  _process_auth "auth.chatgpt.json"      "CHATGPT_TOKEN_DIR"      "CHATGPT_AUTH_FILE"
  _process_auth "auth.gemini_cli.json"    "GEMINI_CLI_TOKEN_DIR"   "GEMINI_CLI_AUTH_FILE"
  _process_auth "auth.qwen_portal.json"   "QWEN_PORTAL_TOKEN_DIR"  "QWEN_PORTAL_AUTH_FILE"
  _process_auth "auth.kimi_code.json"     "KIMI_CODE_TOKEN_DIR"    "KIMI_CODE_AUTH_FILE"

  if [ $changed -eq 0 ]; then
    printf "\n"
    info "All auth paths already up to date."
  else
    printf "\n"
    info ".env updated — no existing entries were removed."
  fi
}

cmd_uninstall_service() {
  if is_macos; then
    launchd_uninstall
  elif is_linux && [ -f "$SYSTEMD_FILE" ]; then
    systemd_uninstall
  else
    nohup_stop
    rm -f "$PIDFILE" "$PORT_FILE"
    info "Cleaned up nohup-managed proxy."
  fi
}

cmd_status() {
  activate_venv
  load_env
  python3 "$BIN_DIR/auth" status

  local port pid
  port=$(get_proxy_port)

  printf "\033[1mProxy\033[0m\n"

  if is_macos && launchd_is_running; then
    pid=$(find_proxy_pid)
    printf "  Service: \033[32mrunning\033[0m (launchd, auto-start enabled)\n"
    printf "  Port:    %s\n" "$port"
    [ -n "$pid" ] && printf "  PID:     %s\n" "$pid"
    printf "\n"
  elif is_linux && systemd_is_running; then
    pid=$(find_proxy_pid)
    printf "  Service: \033[32mrunning\033[0m (systemd, auto-start enabled)\n"
    printf "  Port:    %s\n" "$port"
    [ -n "$pid" ] && printf "  PID:     %s\n" "$pid"
    printf "\n"
  elif nohup_is_running; then
    pid=$(find_proxy_pid)
    [ -z "$pid" ] && [ -f "$PIDFILE" ] && pid=$(cat "$PIDFILE")
    printf "  Service: \033[32mrunning\033[0m (nohup, background)\n"
    printf "  Port:    %s\n" "$port"
    [ -n "$pid" ] && printf "  PID:     %s\n" "$pid"
    printf "\n"
  else
    pid=$(find_proxy_pid)
    if [ -n "$pid" ]; then
      printf "  PID %s running on port %s (foreground)\n\n" "$pid" "$port"
    else
      printf "  \033[33mNot running\033[0m\n\n"
    fi
  fi
}

cmd_wizard() {
  activate_venv
  load_env
  exec python3 "$BIN_DIR/wizard" "$@"
}

show_help() {
  cat <<EOF

$(printf "\033[1mlitellmctl — LiteLLM Proxy Control\033[0m")

$(printf "\033[1mUsage:\033[0m")  litellmctl <command> [args...]

$(printf "\033[1mCommands:\033[0m")
  wizard               Interactive config.yaml generator (providers, tiers, fallbacks)
  install              Install, update, or rebuild LiteLLM
  init-env             Detect auth files and update .env with correct paths
  auth chatgpt         Login to ChatGPT / Codex (browser PKCE)
  auth gemini          Login to Gemini CLI (browser PKCE)
  auth qwen            Login to Qwen Portal (device-code)
  auth kimi            Login to Kimi Code (device-code)
  auth refresh <p>     Refresh token for <chatgpt|gemini|qwen|kimi>
  auth export [p...]   Copy credentials as a paste-able transfer script
  auth import          Read credentials from stdin
  auth status          Show auth token status
  start [--port N]     Start proxy as background service (auto-start on boot)
  stop                 Stop the proxy service
  restart | r          Restart the proxy service
  logs                 Tail proxy logs
  proxy [--port N]     Start proxy in foreground (for debugging)
  uninstall-service    Remove the system service
  status               Show auth + proxy status
  toggle-claude        Toggle Claude Code between direct API and proxy
  setup-completions    Add litellmctl to your shell
  help                 Show this help

$(printf "\033[1mService:\033[0m")
  macOS: launchd agent (~/Library/LaunchAgents/)
  Linux: systemd user unit (~/.config/systemd/user/)
  Fallback: nohup background (servers without systemd user bus)

EOF
}

# ── Main ────────────────────────────────────────────────────────────────────

if [[ $# -eq 0 ]]; then
  show_help
  exit 0
fi

case "$1" in
  --completions)     generate_completions; exit 0 ;;
  --zsh-completions) generate_zsh_completions; exit 0 ;;
  wizard)            shift; cmd_wizard "$@" ;;
  install)           shift; cmd_install "$@" ;;
  update)            warn "'update' has been folded into 'install'."; info "Run: litellmctl install [--local]"; exit 0 ;;
  init-env)          shift; cmd_init_env ;;
  auth)              shift; cmd_auth "$@" ;;
  start)             shift; cmd_start "$@" ;;
  stop)              shift; cmd_stop ;;
  restart|r)         shift; cmd_restart ;;
  logs)              shift; cmd_logs ;;
  proxy)             shift; cmd_proxy "$@" ;;
  uninstall-service) shift; cmd_uninstall_service ;;
  setup-completions) shift; cmd_setup_completions ;;
  status)            shift; cmd_status "$@" ;;
  toggle-claude)     exec "$BIN_DIR/toggle-claude" ;;
  help|-h|--help)    show_help ;;
  *)                 error "Unknown command: $1"; show_help; exit 1 ;;
esac
