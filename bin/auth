#!/usr/bin/env python3
"""
LiteLLM Auth CLI — OAuth login for custom providers.

Usage:
    auth chatgpt              Browser-based PKCE login for ChatGPT / Codex
    auth gemini               Browser-based PKCE login for Gemini CLI
    auth qwen                 Device-code login for Qwen Portal
    auth kimi                 Device-code login for Kimi Code
    auth refresh <name>       Refresh existing token
    auth status               Show token status for all providers
    auth export [providers]   Copy credentials as a paste-able transfer script
    auth import               Read credentials from stdin
"""

import base64
import hashlib
import json
import os
import re
import secrets
import select
import shutil
import sys
import threading
import time
import webbrowser
from http.server import BaseHTTPRequestHandler, HTTPServer
from pathlib import Path
from typing import Optional
from urllib.parse import parse_qs, urlencode, urlparse

try:
    import httpx
except ImportError:
    httpx = None

SCRIPT_DIR = Path(__file__).resolve().parent
PROJECT_DIR = SCRIPT_DIR.parent

# ── Helpers ─────────────────────────────────────────────────────────────────

def _load_env():
    env_file = PROJECT_DIR / ".env"
    if not env_file.exists():
        return
    for line in env_file.read_text().splitlines():
        line = line.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        key, _, value = line.partition("=")
        key, value = key.strip(), value.strip()
        if key and key not in os.environ:
            os.environ[key] = value


def _http_post(url: str, *, data: Optional[dict] = None,
               json_body: Optional[dict] = None,
               headers: Optional[dict] = None) -> dict:
    if httpx:
        with httpx.Client(timeout=30) as client:
            resp = client.post(url, json=json_body, data=data, headers=headers)
            resp.raise_for_status()
            return resp.json()
    import urllib.request, urllib.parse
    if json_body:
        body = json.dumps(json_body).encode()
        headers = {**(headers or {}), "Content-Type": "application/json"}
    else:
        body = urllib.parse.urlencode(data or {}).encode()
        headers = {**(headers or {}), "Content-Type": "application/x-www-form-urlencoded"}
    req = urllib.request.Request(url, data=body, headers=headers, method="POST")
    with urllib.request.urlopen(req, timeout=30) as resp:
        return json.loads(resp.read())


def _http_get(url: str, headers: Optional[dict] = None) -> dict:
    if httpx:
        with httpx.Client(timeout=30) as client:
            resp = client.get(url, headers=headers)
            resp.raise_for_status()
            return resp.json()
    import urllib.request
    req = urllib.request.Request(url, headers=headers or {})
    with urllib.request.urlopen(req, timeout=30) as resp:
        return json.loads(resp.read())


def _generate_pkce() -> tuple:
    verifier = secrets.token_urlsafe(32)
    challenge = (
        base64.urlsafe_b64encode(hashlib.sha256(verifier.encode()).digest())
        .rstrip(b"=")
        .decode()
    )
    return verifier, challenge


def _decode_jwt(token: str) -> dict:
    try:
        payload = token.split(".")[1]
        payload += "=" * (-len(payload) % 4)
        return json.loads(base64.urlsafe_b64decode(payload))
    except Exception:
        return {}


def _capture_callback(port: int, path: str, expected_state: str, timeout: int = 300) -> str:
    result = {}

    class Handler(BaseHTTPRequestHandler):
        def do_GET(self):
            parsed = urlparse(self.path)
            if parsed.path != path:
                self.send_response(404); self.end_headers(); return

            params = parse_qs(parsed.query)
            code = params.get("code", [None])[0]
            state = params.get("state", [None])[0]
            error = params.get("error", [None])[0]

            if error:
                result["error"] = error
            elif state != expected_state:
                result["error"] = f"State mismatch"
            elif code:
                result["code"] = code

            self.send_response(200)
            self.send_header("Content-Type", "text/html; charset=utf-8")
            self.end_headers()
            self.wfile.write(
                b"<html><body><h2>Authentication successful!</h2>"
                b"<p>You can close this tab.</p></body></html>"
            )

        def log_message(self, *a): pass

    server = HTTPServer(("localhost", port), Handler)
    server.timeout = timeout
    server.handle_request()
    server.server_close()

    if "error" in result:
        raise RuntimeError(f"OAuth error: {result['error']}")
    if "code" not in result:
        raise RuntimeError("Timed out waiting for OAuth callback.")
    return result["code"]


# ── Environment detection ──────────────────────────────────────────────────

def _is_headless() -> bool:
    if os.getenv("SSH_CLIENT") or os.getenv("SSH_TTY") or os.getenv("SSH_CONNECTION"):
        return True
    if sys.platform.startswith("linux"):
        if not os.getenv("DISPLAY") and not os.getenv("WAYLAND_DISPLAY"):
            return True
    if os.path.exists("/.dockerenv"):
        return True
    return False


def _extract_code_from_url(url: str, expected_state: str) -> Optional[str]:
    params = parse_qs(urlparse(url).query)
    code = params.get("code", [None])[0]
    state = params.get("state", [None])[0]
    if not code:
        return None
    if state and state != expected_state:
        raise RuntimeError("State mismatch in pasted URL.")
    return code


def _get_auth_code(auth_url: str, port: int, path: str,
                   state: str, timeout: int = 300) -> str:
    headless = _is_headless()

    if not headless:
        webbrowser.open(auth_url)
        return _capture_callback(port, path, state, timeout)

    # Headless / server mode
    print(f"\n  {'Copy and open this URL in your local browser:'}\n")
    print(f"  {auth_url}\n")
    print(f"  After authenticating, do one of:")
    print(f"    A) Paste the redirect URL below")
    print(f"    B) Use SSH tunnel so the callback arrives automatically:")
    print(f"       ssh -L {port}:localhost:{port} <this-server>\n")

    server_result = {}

    def run_server():
        try:
            server_result["code"] = _capture_callback(port, path, state, timeout)
        except Exception as e:
            server_result["error"] = str(e)

    t = threading.Thread(target=run_server, daemon=True)
    t.start()

    sys.stdout.write("  Redirect URL (or wait for callback): ")
    sys.stdout.flush()

    while t.is_alive():
        if "code" in server_result:
            print(f"\n  Callback received via SSH tunnel!")
            return server_result["code"]

        try:
            readable, _, _ = select.select([sys.stdin], [], [], 1.0)
        except (ValueError, OSError):
            t.join(1.0)
            continue

        if readable:
            line = sys.stdin.readline().strip()
            if not line:
                continue
            code = _extract_code_from_url(line, state)
            if code:
                return code
            print("  Could not extract code. Paste the full redirect URL.")
            sys.stdout.write("  Redirect URL: ")
            sys.stdout.flush()

    if "code" in server_result:
        return server_result["code"]
    raise RuntimeError(server_result.get("error", "Timed out waiting for auth code."))


# ── Terminal colors ─────────────────────────────────────────────────────────

_TTY = sys.stdout.isatty()
def _c(t, c): return f"\033[{c}m{t}\033[0m" if _TTY else t
def _green(t):  return _c(t, "32")
def _yellow(t): return _c(t, "33")
def _red(t):    return _c(t, "31")
def _cyan(t):   return _c(t, "36")
def _bold(t):   return _c(t, "1")
def _dim(t):    return _c(t, "2")


# ═══════════════════════════════════════════════════════════════════════════
# ChatGPT / Codex
# ═══════════════════════════════════════════════════════════════════════════

CHATGPT_CLIENT_ID = "app_EMoamEEZ73f0CkXaXp7hrann"
CHATGPT_AUTHORIZE_URL = "https://auth.openai.com/oauth/authorize"
CHATGPT_TOKEN_URL = "https://auth.openai.com/oauth/token"
CHATGPT_REDIRECT_PORT = 1455
CHATGPT_REDIRECT_URI = f"http://localhost:{CHATGPT_REDIRECT_PORT}/auth/callback"
CHATGPT_SCOPES = "openid profile email offline_access"


def _chatgpt_auth_file() -> Path:
    d = os.getenv("CHATGPT_TOKEN_DIR", str(PROJECT_DIR))
    n = os.getenv("CHATGPT_AUTH_FILE", "auth.chatgpt.json")
    return Path(d) / n


def chatgpt_login() -> dict:
    verifier, challenge = _generate_pkce()
    state = secrets.token_urlsafe(16)

    params = {
        "response_type": "code",
        "client_id": CHATGPT_CLIENT_ID,
        "redirect_uri": CHATGPT_REDIRECT_URI,
        "scope": CHATGPT_SCOPES,
        "code_challenge": challenge,
        "code_challenge_method": "S256",
        "state": state,
        "id_token_add_organizations": "true",
        "codex_cli_simplified_flow": "true",
        "originator": "codex_cli_rs",
    }
    auth_url = f"{CHATGPT_AUTHORIZE_URL}?{urlencode(params)}"

    print()
    print(_bold("ChatGPT / Codex OAuth Login"))
    print(_dim("─" * 40))

    if not _is_headless():
        print(f"Opening browser...")
        print(f"Sign in with your OpenAI account.")
        print(f"Waiting for callback on localhost:{CHATGPT_REDIRECT_PORT}...\n")
    else:
        print("Sign in with your OpenAI account.")

    code = _get_auth_code(auth_url, CHATGPT_REDIRECT_PORT, "/auth/callback", state)

    print(_green("✓ Got authorization code. Exchanging for tokens..."))

    data = _http_post(CHATGPT_TOKEN_URL, data={
        "grant_type": "authorization_code",
        "client_id": CHATGPT_CLIENT_ID,
        "code": code,
        "code_verifier": verifier,
        "redirect_uri": CHATGPT_REDIRECT_URI,
    })

    access_token = data["access_token"]
    refresh_token = data["refresh_token"]
    id_token = data.get("id_token")
    claims = _decode_jwt(access_token)
    expires_at = claims.get("exp") or int(time.time() + data.get("expires_in", 3600))
    account_id = claims.get("https://api.openai.com/auth", {}).get("chatgpt_account_id")

    record = {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "id_token": id_token,
        "expires_at": int(expires_at),
        "account_id": account_id,
    }
    f = _chatgpt_auth_file()
    f.parent.mkdir(parents=True, exist_ok=True)
    f.write_text(json.dumps(record, indent=2) + "\n")
    print(_green(f"✓ Saved to {f}"))
    _show_token("ChatGPT", record)
    return record


def chatgpt_refresh() -> dict:
    f = _chatgpt_auth_file()
    if not f.exists():
        raise RuntimeError(f"No auth file at {f}. Run 'auth chatgpt' first.")
    auth = json.loads(f.read_text())
    rt = auth.get("refresh_token")
    if not rt:
        raise RuntimeError("No refresh_token. Run 'auth chatgpt' to re-login.")

    print(_dim("Refreshing ChatGPT token..."))
    data = _http_post(CHATGPT_TOKEN_URL, json_body={
        "client_id": CHATGPT_CLIENT_ID,
        "grant_type": "refresh_token",
        "refresh_token": rt,
        "scope": CHATGPT_SCOPES,
    })

    at = data["access_token"]
    claims = _decode_jwt(at)
    expires_at = claims.get("exp") or int(time.time() + data.get("expires_in", 3600))
    account_id = claims.get("https://api.openai.com/auth", {}).get("chatgpt_account_id")

    record = {
        "access_token": at,
        "refresh_token": data.get("refresh_token", rt),
        "id_token": data.get("id_token"),
        "expires_at": int(expires_at),
        "account_id": account_id,
    }
    f.write_text(json.dumps(record, indent=2) + "\n")
    print(_green(f"✓ Refreshed → {f}"))
    _show_token("ChatGPT", record)
    return record


# ═══════════════════════════════════════════════════════════════════════════
# Gemini CLI
# ═══════════════════════════════════════════════════════════════════════════

GEMINI_AUTH_URL = "https://accounts.google.com/o/oauth2/v2/auth"
GEMINI_TOKEN_URL = "https://oauth2.googleapis.com/token"
GEMINI_USERINFO_URL = "https://www.googleapis.com/oauth2/v1/userinfo?alt=json"
GEMINI_CODE_ASSIST_URL = "https://cloudcode-pa.googleapis.com"
GEMINI_REDIRECT_PORT = 8085
GEMINI_REDIRECT_URI = f"http://localhost:{GEMINI_REDIRECT_PORT}/oauth2callback"
GEMINI_SCOPES = (
    "https://www.googleapis.com/auth/cloud-platform "
    "https://www.googleapis.com/auth/userinfo.email "
    "https://www.googleapis.com/auth/userinfo.profile"
)

_CID_RE = re.compile(r"\d+-[a-z0-9]+\.apps\.googleusercontent\.com")
_CSEC_RE = re.compile(r"GOCSPX-[A-Za-z0-9_-]+")


def _gemini_auth_file() -> Path:
    d = os.getenv("GEMINI_CLI_TOKEN_DIR", str(PROJECT_DIR))
    n = os.getenv("GEMINI_CLI_AUTH_FILE", "auth.gemini_cli.json")
    return Path(d) / n


def _find_oauth2_js() -> Optional[str]:
    """Find gemini-cli-core's oauth2.js across npm, bun, pnpm, yarn layouts."""
    OAUTH_SUBPATH = "@google/gemini-cli-core/dist/src/code_assist/oauth2.js"

    candidates = []

    gemini_bin = shutil.which("gemini")
    if gemini_bin:
        real = os.path.realpath(gemini_bin)
        # Walk up from the resolved binary looking for node_modules
        d = os.path.dirname(real)
        for _ in range(10):
            nm = os.path.join(d, "node_modules", OAUTH_SUBPATH)
            if os.path.isfile(nm):
                return nm
            parent = os.path.dirname(d)
            if parent == d:
                break
            d = parent

    # Common global install paths
    home = os.path.expanduser("~")
    candidates += [
        # bun
        os.path.join(home, ".bun/install/global/node_modules", OAUTH_SUBPATH),
        # npm (macOS Homebrew)
        "/usr/local/lib/node_modules/" + OAUTH_SUBPATH,
        # npm (Linux)
        "/usr/lib/node_modules/" + OAUTH_SUBPATH,
        # npm prefix
        os.path.join(home, ".npm-global/lib/node_modules", OAUTH_SUBPATH),
        # nvm
        *(
            [os.path.join(os.getenv("NVM_DIR", ""), f"versions/node/{v}/lib/node_modules", OAUTH_SUBPATH)
             for v in os.listdir(os.path.join(os.getenv("NVM_DIR", home + "/.nvm"), "versions/node"))
            ] if os.path.isdir(os.path.join(os.getenv("NVM_DIR", home + "/.nvm"), "versions/node")) else []
        ),
    ]

    for p in candidates:
        if os.path.isfile(p):
            return p
    return None


def _gemini_creds() -> tuple:
    cid = os.getenv("GEMINI_CLI_OAUTH_CLIENT_ID")
    csec = os.getenv("GEMINI_CLI_OAUTH_CLIENT_SECRET")
    if cid and csec:
        return cid, csec

    oauth_js = _find_oauth2_js()
    if oauth_js:
        try:
            txt = open(oauth_js).read()
            m_id, m_sec = _CID_RE.search(txt), _CSEC_RE.search(txt)
            if m_id and m_sec:
                return m_id.group(), m_sec.group()
        except Exception:
            pass

    raise RuntimeError(
        "Cannot resolve Gemini CLI OAuth credentials.\n"
        "Add to .env:\n"
        "  GEMINI_CLI_OAUTH_CLIENT_ID=...\n"
        "  GEMINI_CLI_OAUTH_CLIENT_SECRET=...\n"
        "Or install: npm/bun install -g @google/gemini-cli"
    )


def _discover_project(token: str) -> Optional[str]:
    env_project = os.getenv("GOOGLE_CLOUD_PROJECT") or os.getenv("GOOGLE_CLOUD_PROJECT_ID")
    headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}

    try:
        body = {}
        if env_project:
            body["cloudaicompanionProject"] = env_project

        data = _http_post(
            f"{GEMINI_CODE_ASSIST_URL}/v1internal:loadCodeAssist",
            json_body=body, headers=headers,
        )

        cap = data.get("cloudaicompanionProject")
        if isinstance(cap, dict):
            return cap.get("id")
        if isinstance(cap, str):
            return cap

        pid = data.get("projectId") or data.get("project_id")
        if pid:
            return pid
    except Exception as e:
        print(_yellow(f"  loadCodeAssist failed (non-fatal): {e}"))

    # Fall back to listing GCP projects
    found_project = env_project
    if not found_project:
        try:
            projects = _http_get(
                "https://cloudresourcemanager.googleapis.com/v1/projects",
                headers={"Authorization": f"Bearer {token}"},
            ).get("projects", [])
            for p in projects:
                if "gemini" in p.get("name", "").lower() or "lang" in p.get("projectId", ""):
                    found_project = p["projectId"]
                    break
            if not found_project and projects:
                found_project = projects[0]["projectId"]
            if found_project:
                print(_dim(f"  Using GCP project: {found_project}"))
        except Exception as e:
            print(_yellow(f"  GCP project listing failed (non-fatal): {e}"))

    # Onboard the project with Code Assist if we found one
    if found_project:
        try:
            _http_post(
                f"{GEMINI_CODE_ASSIST_URL}/v1internal:onboardUser",
                json_body={
                    "tierId": "standard-tier",
                    "cloudaicompanionProject": found_project,
                    "metadata": {"ideType": "IDE_UNSPECIFIED", "platform": "PLATFORM_UNSPECIFIED"},
                },
                headers=headers,
            )
        except Exception:
            pass
        # Also enable the Code Assist API on the project
        try:
            _http_post(
                f"https://serviceusage.googleapis.com/v1/projects/{found_project}/services/cloudaicompanion.googleapis.com:enable",
                json_body={}, headers=headers,
            )
        except Exception:
            pass

    return found_project


def gemini_login() -> dict:
    cid, csec = _gemini_creds()
    verifier, challenge = _generate_pkce()
    state = secrets.token_urlsafe(16)

    params = {
        "client_id": cid, "response_type": "code",
        "redirect_uri": GEMINI_REDIRECT_URI, "scope": GEMINI_SCOPES,
        "code_challenge": challenge, "code_challenge_method": "S256",
        "state": state, "access_type": "offline", "prompt": "consent",
    }
    auth_url = f"{GEMINI_AUTH_URL}?{urlencode(params)}"

    print()
    print(_bold("Gemini CLI OAuth Login"))
    print(_dim("─" * 40))

    if not _is_headless():
        print("Opening browser...")
        print("Sign in with your Google account.")
        print(f"Waiting for callback on localhost:{GEMINI_REDIRECT_PORT}...\n")
    else:
        print("Sign in with your Google account.")

    code = _get_auth_code(auth_url, GEMINI_REDIRECT_PORT, "/oauth2callback", state)

    print(_green("✓ Got authorization code. Exchanging for tokens..."))
    data = _http_post(GEMINI_TOKEN_URL, data={
        "grant_type": "authorization_code", "code": code,
        "redirect_uri": GEMINI_REDIRECT_URI, "client_id": cid,
        "client_secret": csec, "code_verifier": verifier,
    })

    at = data["access_token"]
    rt = data.get("refresh_token")
    if not rt:
        raise RuntimeError("No refresh_token received. Try again.")

    print(_dim("  Discovering project & email..."))
    pid = _discover_project(at)
    email = None
    try:
        email = _http_get(GEMINI_USERINFO_URL, headers={"Authorization": f"Bearer {at}"}).get("email")
    except Exception:
        pass

    record = {
        "access_token": at, "refresh_token": rt,
        "expires_at": int(time.time() + data.get("expires_in", 3600)),
        "project_id": pid, "email": email,
    }
    f = _gemini_auth_file()
    f.parent.mkdir(parents=True, exist_ok=True)
    f.write_text(json.dumps(record, indent=2) + "\n")
    print(_green(f"✓ Saved to {f}"))
    _show_token("Gemini CLI", record)
    return record


def gemini_refresh() -> dict:
    f = _gemini_auth_file()
    if not f.exists():
        raise RuntimeError(f"No auth file at {f}. Run 'auth gemini' first.")
    auth = json.loads(f.read_text())
    rt = auth.get("refresh_token")
    if not rt:
        raise RuntimeError("No refresh_token. Run 'auth gemini' to re-login.")

    cid, csec = _gemini_creds()
    print(_dim("Refreshing Gemini CLI token..."))
    data = _http_post(GEMINI_TOKEN_URL, data={
        "grant_type": "refresh_token", "refresh_token": rt,
        "client_id": cid, "client_secret": csec,
    })

    at = data["access_token"]
    auth["access_token"] = at
    auth["refresh_token"] = data.get("refresh_token", rt)
    auth["expires_at"] = int(time.time() + data.get("expires_in", 3600))

    if not auth.get("project_id"):
        print(_dim("  Discovering project..."))
        auth["project_id"] = _discover_project(at)

    if not auth.get("email"):
        try:
            auth["email"] = _http_get(
                GEMINI_USERINFO_URL, headers={"Authorization": f"Bearer {at}"}
            ).get("email")
        except Exception:
            pass

    f.write_text(json.dumps(auth, indent=2) + "\n")
    print(_green(f"✓ Refreshed → {f}"))
    _show_token("Gemini CLI", auth)
    return auth


# ═══════════════════════════════════════════════════════════════════════════
# Qwen Portal (device-code OAuth via chat.qwen.ai)
# Follows OpenClaw's approach for Qwen authentication.
# ═══════════════════════════════════════════════════════════════════════════

QWEN_OAUTH_BASE = "https://chat.qwen.ai"
QWEN_DEVICE_CODE_URL = f"{QWEN_OAUTH_BASE}/api/v1/oauth2/device/code"
QWEN_TOKEN_URL = f"{QWEN_OAUTH_BASE}/api/v1/oauth2/token"
QWEN_CLIENT_ID = "f0304373b74a44d2b584a3fb70ca9e56"
QWEN_OAUTH_SCOPE = "openid profile email model.completion"
QWEN_DEVICE_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:device_code"
QWEN_USER_AGENT = "qwen-code/1.0.0"
QWEN_POLL_INTERVAL = 2
QWEN_MAX_POLL_INTERVAL = 10


def _qwen_auth_file() -> Path:
    d = os.getenv("QWEN_PORTAL_TOKEN_DIR", str(PROJECT_DIR))
    n = os.getenv("QWEN_PORTAL_AUTH_FILE", "auth.qwen_portal.json")
    return Path(d) / n


def _qwen_request_device_code(code_challenge: str) -> dict:
    """Request a device code from the Qwen OAuth server."""
    import uuid
    form_data = urlencode({
        "client_id": QWEN_CLIENT_ID,
        "scope": QWEN_OAUTH_SCOPE,
        "code_challenge": code_challenge,
        "code_challenge_method": "S256",
    })
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/json",
        "User-Agent": QWEN_USER_AGENT,
        "x-request-id": str(uuid.uuid4()),
    }
    if httpx:
        with httpx.Client(timeout=30, follow_redirects=True) as client:
            resp = client.post(QWEN_DEVICE_CODE_URL, content=form_data, headers=headers)
            resp.raise_for_status()
            return resp.json()
    import urllib.request
    req = urllib.request.Request(
        QWEN_DEVICE_CODE_URL, data=form_data.encode(),
        headers=headers, method="POST")
    with urllib.request.urlopen(req, timeout=30) as resp:
        return json.loads(resp.read())


def _qwen_poll_token(device_code: str, code_verifier: str) -> Optional[dict]:
    """Poll for the device token. Returns token data or None if still pending."""
    form_data = urlencode({
        "grant_type": QWEN_DEVICE_GRANT_TYPE,
        "client_id": QWEN_CLIENT_ID,
        "device_code": device_code,
        "code_verifier": code_verifier,
    })
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/json",
        "User-Agent": QWEN_USER_AGENT,
    }

    if httpx:
        with httpx.Client(timeout=30, follow_redirects=True) as client:
            resp = client.post(QWEN_TOKEN_URL, content=form_data, headers=headers)
            if resp.status_code == 200:
                body = resp.json()
                at = body.get("access_token")
                if at and isinstance(at, str) and len(at) > 0:
                    return body
                if body.get("status") == "pending":
                    return None
                return None
            if resp.status_code == 400:
                try:
                    body = resp.json()
                except Exception:
                    return None
                if body.get("error") == "authorization_pending":
                    return None
                raise RuntimeError(
                    f"Device token error: {body.get('error', 'unknown')} — "
                    f"{body.get('error_description', '')}")
            if resp.status_code == 429:
                return None
            resp.raise_for_status()
    else:
        import urllib.request, urllib.error
        req = urllib.request.Request(
            QWEN_TOKEN_URL, data=form_data.encode(),
            headers=headers, method="POST")
        try:
            with urllib.request.urlopen(req, timeout=30) as resp:
                body = json.loads(resp.read())
                at = body.get("access_token")
                if at and isinstance(at, str) and len(at) > 0:
                    return body
                return None
        except urllib.error.HTTPError as e:
            if e.code in (400, 429):
                return None
            raise
    return None


def _qwen_try_sync_cli_creds() -> Optional[dict]:
    """Try to load valid credentials from Qwen Code CLI's ~/.qwen/oauth_creds.json."""
    cli_path = Path.home() / ".qwen" / "oauth_creds.json"
    if not cli_path.exists():
        return None
    try:
        data = json.loads(cli_path.read_text())
    except (json.JSONDecodeError, IOError):
        return None

    access_token = data.get("access_token")
    expiry_date = data.get("expiry_date")
    if not access_token or not expiry_date:
        return None

    # expiry_date is in milliseconds in Qwen CLI format
    expires_at = expiry_date / 1000.0 if expiry_date > 1e12 else expiry_date
    if time.time() >= expires_at - 60:
        return None  # expired

    return {
        "access_token": access_token,
        "refresh_token": data.get("refresh_token"),
        "expires_at": int(expires_at),
        "resource_url": data.get("resource_url"),
        "token_type": data.get("token_type", "Bearer"),
    }


def qwen_login() -> dict:
    verifier, challenge = _generate_pkce()

    print()
    print(_bold("Qwen Portal OAuth Login (Device Code)"))
    print(_dim("─" * 40))
    print(_dim("Requesting device code..."))

    device_resp = _qwen_request_device_code(challenge)

    device_code = device_resp.get("device_code")
    user_code = device_resp.get("user_code")
    verify_url = device_resp.get("verification_uri_complete") or device_resp.get("verification_uri", "")
    expires_in = int(device_resp.get("expires_in", 600))

    if not device_code:
        raise RuntimeError(f"Device code response missing device_code: {device_resp}")

    print()
    if user_code:
        print(f"  Your code: {_bold(user_code)}")
    print(f"  Open this URL in your browser:\n")
    print(f"  {_cyan(verify_url)}\n")

    if not _is_headless():
        try:
            webbrowser.open(verify_url)
            print(_dim("  (Browser opened automatically)"))
        except Exception:
            pass

    print(_dim(f"\n  Waiting for authorization (expires in {expires_in // 60}m)...\n"))

    poll_interval = QWEN_POLL_INTERVAL
    deadline = time.time() + expires_in

    while time.time() < deadline:
        time.sleep(poll_interval)
        try:
            token_data = _qwen_poll_token(device_code, verifier)
        except RuntimeError as e:
            raise RuntimeError(f"Qwen auth failed: {e}")

        if token_data is not None:
            print(_green("✓ Authorization successful! Token obtained."))

            at = token_data["access_token"]
            expires_in_secs = token_data.get("expires_in", 3600)
            resource_url = token_data.get("resource_url")

            record = {
                "access_token": at,
                "refresh_token": token_data.get("refresh_token"),
                "expires_at": int(time.time() + expires_in_secs),
                "resource_url": resource_url,
                "token_type": token_data.get("token_type", "Bearer"),
            }
            f = _qwen_auth_file()
            f.parent.mkdir(parents=True, exist_ok=True)
            f.write_text(json.dumps(record, indent=2) + "\n")
            print(_green(f"✓ Saved to {f}"))
            _show_token("Qwen Portal", record)
            return record

        # No slow_down handling needed — the poll function returns None for 429
        poll_interval = min(poll_interval + 0.5, QWEN_MAX_POLL_INTERVAL)

    raise RuntimeError("Timed out waiting for Qwen device authorization.")


def qwen_refresh() -> dict:
    f = _qwen_auth_file()
    if not f.exists():
        # Try syncing from Qwen CLI
        synced = _qwen_try_sync_cli_creds()
        if synced:
            f.parent.mkdir(parents=True, exist_ok=True)
            f.write_text(json.dumps(synced, indent=2) + "\n")
            print(_green(f"✓ Synced from Qwen Code CLI → {f}"))
            _show_token("Qwen Portal", synced)
            return synced
        raise RuntimeError(f"No auth file at {f}. Run 'auth qwen' first.")

    auth = json.loads(f.read_text())
    rt = auth.get("refresh_token")
    if not rt:
        raise RuntimeError("No refresh_token. Run 'auth qwen' to re-login.")

    print(_dim("Refreshing Qwen Portal token..."))
    form_data = urlencode({
        "grant_type": "refresh_token",
        "refresh_token": rt,
        "client_id": QWEN_CLIENT_ID,
    })
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/json",
        "User-Agent": QWEN_USER_AGENT,
    }
    if httpx:
        with httpx.Client(timeout=30, follow_redirects=True) as client:
            resp = client.post(QWEN_TOKEN_URL, content=form_data, headers=headers)
            resp.raise_for_status()
            data = resp.json()
    else:
        import urllib.request
        req = urllib.request.Request(
            QWEN_TOKEN_URL, data=form_data.encode(),
            headers=headers, method="POST")
        with urllib.request.urlopen(req, timeout=30) as resp:
            data = json.loads(resp.read())

    at = data.get("access_token")
    if not at:
        raise RuntimeError(f"Refresh response missing access_token: {data}")

    expires_in_secs = data.get("expires_in", 3600)
    resource_url = data.get("resource_url") or auth.get("resource_url")

    record = {
        "access_token": at,
        "refresh_token": data.get("refresh_token", rt),
        "expires_at": int(time.time() + expires_in_secs),
        "resource_url": resource_url,
        "token_type": data.get("token_type", "Bearer"),
    }
    f.write_text(json.dumps(record, indent=2) + "\n")
    print(_green(f"✓ Refreshed → {f}"))
    _show_token("Qwen Portal", record)
    return record


# ═══════════════════════════════════════════════════════════════════════════
# Kimi Code (device-code OAuth via auth.kimi.com)
# ═══════════════════════════════════════════════════════════════════════════

KIMI_OAUTH_HOST = "https://auth.kimi.com"
KIMI_DEVICE_AUTH_URL = f"{KIMI_OAUTH_HOST}/api/oauth/device_authorization"
KIMI_TOKEN_URL = f"{KIMI_OAUTH_HOST}/api/oauth/token"
KIMI_CLIENT_ID = "17e5f671-d194-4dfb-9706-5516cb48c098"
KIMI_USER_AGENT = "KimiCLI/1.12.0"
KIMI_POLL_INTERVAL = 5
KIMI_DEFAULT_API_BASE = "https://api.kimi.com/coding/v1"


def _kimi_auth_file() -> Path:
    d = os.getenv("KIMI_CODE_TOKEN_DIR", str(PROJECT_DIR))
    n = os.getenv("KIMI_CODE_AUTH_FILE", "auth.kimi_code.json")
    return Path(d) / n


def _kimi_common_headers() -> dict:
    import platform, socket
    device_id = ""
    device_id_path = Path.home() / ".kimi" / "device_id"
    if device_id_path.exists():
        device_id = device_id_path.read_text().strip()
    return {
        "User-Agent": KIMI_USER_AGENT,
        "X-Msh-Platform": "kimi_cli",
        "X-Msh-Version": "1.12.0",
        "X-Msh-Device-Id": device_id,
        "X-Msh-Device-Name": platform.node() or socket.gethostname(),
        "X-Msh-Device-Model": f"{platform.system()} {platform.release()} {platform.machine()}",
    }


def _kimi_try_sync_cli_creds() -> Optional[dict]:
    """Try to load valid credentials from kimi-cli's ~/.kimi/credentials/kimi-code.json."""
    cli_path = Path.home() / ".kimi" / "credentials" / "kimi-code.json"
    if not cli_path.exists():
        return None
    try:
        data = json.loads(cli_path.read_text())
    except (json.JSONDecodeError, IOError):
        return None

    access_token = data.get("access_token")
    expires_at = data.get("expires_at")
    if not access_token or not expires_at:
        return None
    if time.time() >= float(expires_at) - 60:
        return None

    return {
        "access_token": access_token,
        "refresh_token": data.get("refresh_token"),
        "expires_at": float(expires_at),
        "scope": data.get("scope", "kimi-code"),
        "token_type": data.get("token_type", "Bearer"),
    }


def _kimi_save_to_cli(record: dict) -> None:
    """Sync tokens back to kimi-cli's credential file."""
    cli_path = Path.home() / ".kimi" / "credentials" / "kimi-code.json"
    cli_record = {
        "access_token": record["access_token"],
        "refresh_token": record["refresh_token"],
        "expires_at": record["expires_at"],
        "scope": record.get("scope", "kimi-code"),
        "token_type": record.get("token_type", "Bearer"),
    }
    try:
        cli_path.parent.mkdir(parents=True, exist_ok=True)
        cli_path.write_text(json.dumps(cli_record))
        os.chmod(cli_path, 0o600)
    except OSError:
        pass


def kimi_login() -> dict:
    print()
    print(_bold("Kimi Code OAuth Login (Device Code)"))
    print(_dim("─" * 40))
    print(_dim("Requesting device code..."))

    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        **_kimi_common_headers(),
    }

    if httpx:
        with httpx.Client(timeout=30) as client:
            resp = client.post(
                KIMI_DEVICE_AUTH_URL,
                data={"client_id": KIMI_CLIENT_ID},
                headers=headers,
            )
            resp.raise_for_status()
            device_resp = resp.json()
    else:
        import urllib.request, urllib.parse
        body = urllib.parse.urlencode({"client_id": KIMI_CLIENT_ID}).encode()
        req = urllib.request.Request(KIMI_DEVICE_AUTH_URL, data=body, headers=headers)
        with urllib.request.urlopen(req, timeout=30) as resp:
            device_resp = json.loads(resp.read())

    device_code = device_resp.get("device_code")
    user_code = device_resp.get("user_code")
    verify_url = device_resp.get("verification_uri_complete", "")
    expires_in = int(device_resp.get("expires_in", 600))
    interval = int(device_resp.get("interval", KIMI_POLL_INTERVAL))

    if not device_code:
        raise RuntimeError(f"Device code response missing device_code: {device_resp}")

    print()
    if user_code:
        print(f"  Your code: {_bold(user_code)}")
    print(f"  Open this URL in your browser:\n")
    print(f"  {_cyan(verify_url)}\n")

    if not _is_headless():
        try:
            webbrowser.open(verify_url)
            print(_dim("  (Browser opened automatically)"))
        except Exception:
            pass

    print(_dim(f"\n  Waiting for authorization (expires in {expires_in // 60}m)...\n"))

    deadline = time.time() + expires_in
    while time.time() < deadline:
        time.sleep(max(interval, 1))

        poll_headers = {
            "Content-Type": "application/x-www-form-urlencoded",
            **_kimi_common_headers(),
        }
        poll_data = {
            "client_id": KIMI_CLIENT_ID,
            "device_code": device_code,
            "grant_type": "urn:ietf:params:oauth:grant-type:device_code",
        }

        try:
            if httpx:
                with httpx.Client(timeout=30) as client:
                    resp = client.post(KIMI_TOKEN_URL, data=poll_data, headers=poll_headers)
                    if resp.status_code == 200:
                        token_data = resp.json()
                        if "access_token" in token_data:
                            break
                    body = resp.json() if resp.status_code < 500 else {}
                    error = body.get("error", "")
                    if error == "expired_token":
                        raise RuntimeError("Device code expired. Please try again.")
                    continue
            else:
                import urllib.request, urllib.parse, urllib.error
                body_bytes = urllib.parse.urlencode(poll_data).encode()
                req = urllib.request.Request(KIMI_TOKEN_URL, data=body_bytes, headers=poll_headers)
                try:
                    with urllib.request.urlopen(req, timeout=30) as resp:
                        token_data = json.loads(resp.read())
                        if "access_token" in token_data:
                            break
                except urllib.error.HTTPError:
                    pass
                continue
        except RuntimeError:
            raise
        except Exception:
            continue
    else:
        raise RuntimeError("Timed out waiting for Kimi device authorization.")

    print(_green("✓ Authorization successful! Token obtained."))

    expires_in_secs = float(token_data.get("expires_in", 900))
    record = {
        "access_token": token_data["access_token"],
        "refresh_token": token_data["refresh_token"],
        "expires_at": time.time() + expires_in_secs,
        "scope": token_data.get("scope", "kimi-code"),
        "token_type": token_data.get("token_type", "Bearer"),
    }
    f = _kimi_auth_file()
    f.parent.mkdir(parents=True, exist_ok=True)
    f.write_text(json.dumps(record, indent=2) + "\n")
    _kimi_save_to_cli(record)
    print(_green(f"✓ Saved to {f}"))
    _show_token("Kimi Code", record)
    return record


def kimi_refresh() -> dict:
    f = _kimi_auth_file()
    if not f.exists():
        synced = _kimi_try_sync_cli_creds()
        if synced:
            f.parent.mkdir(parents=True, exist_ok=True)
            f.write_text(json.dumps(synced, indent=2) + "\n")
            print(_green(f"✓ Synced from kimi-cli → {f}"))
            _show_token("Kimi Code", synced)
            return synced
        raise RuntimeError(f"No auth file at {f}. Run 'auth kimi' or 'kimi login' first.")

    auth = json.loads(f.read_text())
    rt = auth.get("refresh_token")
    if not rt:
        raise RuntimeError("No refresh_token. Run 'auth kimi' to re-login.")

    print(_dim("Refreshing Kimi Code token..."))
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/json",
        **_kimi_common_headers(),
    }
    form_data = urlencode({
        "grant_type": "refresh_token",
        "refresh_token": rt,
        "client_id": KIMI_CLIENT_ID,
    })

    if httpx:
        with httpx.Client(timeout=30) as client:
            resp = client.post(KIMI_TOKEN_URL, content=form_data, headers=headers)
            resp.raise_for_status()
            data = resp.json()
    else:
        import urllib.request
        req = urllib.request.Request(
            KIMI_TOKEN_URL, data=form_data.encode(),
            headers=headers, method="POST")
        with urllib.request.urlopen(req, timeout=30) as resp:
            data = json.loads(resp.read())

    at = data.get("access_token")
    if not at:
        raise RuntimeError(f"Refresh response missing access_token: {data}")

    expires_in_secs = float(data.get("expires_in", 900))
    record = {
        "access_token": at,
        "refresh_token": data.get("refresh_token", rt),
        "expires_at": time.time() + expires_in_secs,
        "scope": data.get("scope", "kimi-code"),
        "token_type": data.get("token_type", "Bearer"),
    }
    f.write_text(json.dumps(record, indent=2) + "\n")
    _kimi_save_to_cli(record)
    print(_green(f"✓ Refreshed → {f}"))
    _show_token("Kimi Code", record)
    return record


# ═══════════════════════════════════════════════════════════════════════════
# Export / Import (credential transfer between machines)
# ═══════════════════════════════════════════════════════════════════════════

_AUTH_PROVIDERS = [
    ("chatgpt", "ChatGPT / Codex", _chatgpt_auth_file),
    ("gemini",  "Gemini CLI",      _gemini_auth_file),
    ("qwen",    "Qwen Portal",     _qwen_auth_file),
    ("kimi",    "Kimi Code",       _kimi_auth_file),
]


def _expiry_label(d: dict) -> str:
    exp = d.get("expires_at")
    if not exp:
        return "unknown expiry"
    rem = int(exp - time.time())
    if rem <= 0:
        return "EXPIRED"
    return f"{rem // 3600}h {(rem % 3600) // 60}m left"


def _copy_to_clipboard(text: str) -> bool:
    """Copy text to system clipboard. Returns True on success."""
    import subprocess
    for cmd in (["pbcopy"], ["xclip", "-selection", "clipboard"], ["xsel", "--clipboard", "--input"]):
        try:
            p = subprocess.Popen(cmd, stdin=subprocess.PIPE)
            p.communicate(text.encode())
            if p.returncode == 0:
                return True
        except FileNotFoundError:
            continue
    return False


def export_creds(selected: list[str] | None = None):
    available = []
    for key, label, getter in _AUTH_PROVIDERS:
        f = getter()
        if f.exists():
            try:
                data = json.loads(f.read_text())
                available.append((key, label, f, data))
            except Exception:
                pass

    if not available:
        print(_red("No auth files found. Run 'litellmctl auth <provider>' first."))
        sys.exit(1)

    if selected:
        chosen = []
        for key, label, f, data in available:
            if key in selected:
                chosen.append((key, label, f, data))
        missing = set(selected) - {k for k, *_ in chosen}
        if missing:
            print(_yellow(f"Not found: {', '.join(missing)}"))
        if not chosen:
            print(_red("No matching auth files.")); sys.exit(1)
    else:
        print()
        print(_bold("Available credentials:"))
        for i, (key, label, f, data) in enumerate(available, 1):
            exp = _expiry_label(data)
            color = _green if "left" in exp else _red
            print(f"  [{i}] {key:<12} {label:<20} ({color(exp)})")

        print()
        ans = input("Select (comma-separated numbers, or 'all') [all]: ").strip()
        if not ans or ans.lower() == "all":
            chosen = available
        else:
            indices = []
            for part in ans.split(","):
                part = part.strip()
                if part.isdigit() and 1 <= int(part) <= len(available):
                    indices.append(int(part) - 1)
            if not indices:
                print(_red("No valid selection.")); sys.exit(1)
            chosen = [available[i] for i in indices]

    # Build self-contained bash transfer script
    lines = [
        "#!/usr/bin/env bash",
        "# litellmctl credential transfer",
        f"# Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}",
        f"# Credentials: {', '.join(k for k, *_ in chosen)}",
        "#",
        "# Paste this entire block into a terminal on the target machine.",
        "set -euo pipefail",
        'D="${LITELLM_DIR:-$HOME/.litellm}"',
        'mkdir -p "$D"',
        "",
    ]

    for key, label, f, data in chosen:
        encoded = base64.b64encode(json.dumps(data, indent=2).encode()).decode()
        fname = f.name
        lines.append(f"# {label}")
        lines.append(f"printf '%s' '{encoded}' | base64 -d > \"$D/{fname}\"")
        lines.append(f'chmod 600 "$D/{fname}"')
        lines.append(f'echo "  ✓ {fname}  ({label})"')
        lines.append("")

    lines.append('echo ""')
    lines.append('echo "Done! Imported to $D"')
    lines.append('[ -x "$D/bin/litellmctl" ] && "$D/bin/litellmctl" init-env 2>/dev/null && echo "  ✓ .env paths synced" || echo "  Run: litellmctl init-env"')

    script = "\n".join(lines) + "\n"

    if _copy_to_clipboard(script):
        print()
        print(_green(f"✓ Copied transfer script to clipboard ({len(chosen)} credential(s))"))
        print(_dim("  Paste it into a terminal on the target machine."))
    else:
        print()
        print(_yellow("Could not copy to clipboard. Printing script:\n"))
        print(_dim("─" * 60))
        print(script)
        print(_dim("─" * 60))

    print()


def import_creds():
    print()
    print(_bold("Import credentials"))
    print(_dim("─" * 40))
    print("Paste base64-encoded credentials (one per line):")
    print("Format:  <filename> <base64>")
    print("Example: auth.chatgpt.json eyJhY2Nlc3...")
    print()
    print(_dim("End with an empty line or Ctrl+D."))
    print()

    imported = 0
    for line in sys.stdin:
        line = line.strip()
        if not line:
            break
        parts = line.split(None, 1)
        if len(parts) != 2:
            print(_yellow(f"  Skipped (bad format): {line[:40]}..."))
            continue

        fname, b64data = parts
        if not fname.startswith("auth.") or not fname.endswith(".json"):
            print(_yellow(f"  Skipped (not auth file): {fname}"))
            continue

        try:
            decoded = base64.b64decode(b64data)
            json.loads(decoded)  # validate JSON
        except Exception:
            print(_red(f"  Invalid base64/JSON for {fname}"))
            continue

        target = PROJECT_DIR / fname
        target.write_bytes(decoded)
        os.chmod(target, 0o600)
        print(_green(f"  ✓ {fname}"))
        imported += 1

    if imported:
        print(f"\n{_green(f'✓ Imported {imported} credential(s)')}")
        print(_dim("  Run: litellmctl init-env"))
    else:
        print(_yellow("\nNo credentials imported."))

    print()


# ═══════════════════════════════════════════════════════════════════════════
# Status
# ═══════════════════════════════════════════════════════════════════════════

def _show_token(provider: str, d: dict):
    exp = d.get("expires_at")
    if exp:
        rem = int(exp - time.time())
        if rem > 0:
            expiry = _green(f"{rem // 3600}h {(rem % 3600) // 60}m remaining")
        else:
            expiry = _red("EXPIRED")
    else:
        expiry = _yellow("unknown")
    print(f"  Provider:   {_bold(provider)}")
    if d.get("email"):      print(f"  Email:      {d['email']}")
    if d.get("account_id"): print(f"  Account:    {d['account_id']}")
    if d.get("project_id"): print(f"  Project:    {d['project_id']}")
    print(f"  Expires:    {expiry}")
    print()


def show_status():
    print()
    print(_bold("LiteLLM Auth Status"))
    print(_dim("═" * 40))

    for label, getter in [("ChatGPT / Codex", _chatgpt_auth_file), ("Gemini CLI", _gemini_auth_file), ("Qwen Portal", _qwen_auth_file), ("Kimi Code", _kimi_auth_file)]:
        f = getter()
        print(f"\n{_bold(label)}")
        print(f"  File: {f}")
        if f.exists():
            try:
                _show_token(label, json.loads(f.read_text()))
            except Exception as e:
                print(_red(f"  Error: {e}\n"))
        else:
            print(_yellow("  Not authenticated\n"))


# ═══════════════════════════════════════════════════════════════════════════
# CLI
# ═══════════════════════════════════════════════════════════════════════════

USAGE = f"""\
{_bold('LiteLLM Auth CLI')}

{_bold('Commands:')}
  auth chatgpt              Login to ChatGPT / Codex (browser PKCE)
  auth gemini               Login to Gemini CLI (browser PKCE)
  auth qwen                 Login to Qwen Portal (device code)
  auth kimi                 Login to Kimi Code (device code)
  auth refresh <name>       Refresh token (chatgpt|gemini|qwen|kimi)
  auth status               Show token status
  auth export [providers]   Copy credentials as a paste-able transfer script
  auth import               Read credentials from stdin
"""

def main():
    _load_env()
    args = sys.argv[1:]

    if not args or args[0] in ("-h", "--help", "help"):
        print(USAGE); return

    cmd = args[0].lower()
    try:
        if cmd in ("chatgpt", "codex", "openai"):
            chatgpt_login()
        elif cmd in ("gemini", "gemini_cli", "gemini-cli"):
            gemini_login()
        elif cmd in ("qwen", "qwen_portal", "qwen-portal"):
            qwen_login()
        elif cmd in ("kimi", "kimi_code", "kimi-code"):
            kimi_login()
        elif cmd == "refresh":
            if len(args) < 2:
                print(_red("Usage: auth refresh <chatgpt|gemini|qwen|kimi>")); sys.exit(1)
            t = args[1].lower()
            if t in ("chatgpt", "codex", "openai"):   chatgpt_refresh()
            elif t in ("gemini", "gemini_cli", "gemini-cli"): gemini_refresh()
            elif t in ("qwen", "qwen_portal", "qwen-portal"): qwen_refresh()
            elif t in ("kimi", "kimi_code", "kimi-code"): kimi_refresh()
            else: print(_red(f"Unknown provider: {t}")); sys.exit(1)
        elif cmd == "export":
            export_creds(args[1:] if len(args) > 1 else None)
        elif cmd == "import":
            import_creds()
        elif cmd == "status":
            show_status()
        else:
            print(_red(f"Unknown command: {cmd}")); print(USAGE); sys.exit(1)
    except KeyboardInterrupt:
        print(_yellow("\nAborted.")); sys.exit(130)
    except RuntimeError as e:
        print(_red(f"\nError: {e}")); sys.exit(1)
    except Exception as e:
        print(_red(f"\n{type(e).__name__}: {e}")); sys.exit(1)


if __name__ == "__main__":
    main()
