#!/usr/bin/env bash
set -euo pipefail

BIN_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_DIR="$(cd "$BIN_DIR/.." && pwd)"
VENV_DIR="$PROJECT_DIR/venv"
SUBMODULE_DIR="$PROJECT_DIR/litellm"

# ── Helpers ──

info()  { printf "\033[1;34m==> %s\033[0m\n" "$*"; }
warn()  { printf "\033[1;33m==> %s\033[0m\n" "$*"; }
error() { printf "\033[1;31m==> %s\033[0m\n" "$*" >&2; }

is_interactive() { [ -t 0 ]; }

# Prevent git from blocking on credential/password prompts.
export GIT_TERMINAL_PROMPT=0
export GIT_SSH_COMMAND="${GIT_SSH_COMMAND:-ssh -o BatchMode=yes -o ConnectTimeout=10}"

# Run a command with a hard timeout (GNU coreutils only).
# Sends SIGKILL 5s after SIGTERM in case the child ignores it.
run_with_timeout() {
  local secs="$1"; shift
  local bin
  bin="$(type -P timeout 2>/dev/null || true)"
  if [ -n "$bin" ]; then
    "$bin" -k 5 "$secs" "$@"
  else
    "$@"
  fi
}

# Check for local uncommitted changes or unpushed commits.
# Does NOT do a git fetch (sync_repo handles that via git pull).
has_local_changes() {
  local dir="$1"
  [ -d "$dir/.git" ] || [ -f "$dir/.git" ] || return 1
  # Uncommitted changes (staged or unstaged)
  ! git -C "$dir" diff --quiet 2>/dev/null && return 0
  ! git -C "$dir" diff --cached --quiet 2>/dev/null && return 0
  # Unpushed commits (vs last known remote head)
  local ahead
  ahead=$(git -C "$dir" rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
  [ "$ahead" -gt 0 ] && return 0
  return 1
}

prompt_local_changes() {
  local dir="$1" label="$2"
  # This function is called inside $() which captures stdout.
  # Display output goes to stderr; only the result word goes to stdout.
  {
    echo ""
    warn "Local changes detected in $label:"
    git -C "$dir" diff --stat 2>/dev/null || true
    git -C "$dir" diff --cached --stat 2>/dev/null || true
    local ahead
    ahead=$(git -C "$dir" rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
    [ "$ahead" -gt 0 ] && info "$ahead unpushed commit(s) ahead of remote"
    echo ""
  } >&2

  if ! is_interactive; then
    warn "Non-interactive terminal — defaulting to [K]eep local." >&2
    echo "keep"
    return
  fi

  printf "  [K]eep local  [S]tash & sync  [D]iscard & sync  [K/s/d] " >&2
  read -r answer </dev/tty || answer=""
  case "$answer" in
    [sS]*) echo "stash" ;;
    [dD]*) echo "discard" ;;
    *)     echo "keep" ;;
  esac
}

sync_repo() {
  local dir="$1" label="$2"
  if has_local_changes "$dir"; then
    local choice
    choice=$(prompt_local_changes "$dir" "$label")
    case "$choice" in
      keep)
        info "Keeping local $label. Skipping sync."
        ;;
      stash)
        info "Stashing $label changes ..."
        git -C "$dir" stash --quiet
        info "Pulling $label ..."
        run_with_timeout 60 git -C "$dir" pull --ff-only --no-recurse-submodules \
          || { error "Pull failed for $label."; exit 1; }
        info "Restoring stashed $label changes ..."
        git -C "$dir" stash pop --quiet 2>/dev/null || {
          warn "Could not auto-restore $label changes. Check: git -C $dir stash list"
        }
        ;;
      discard)
        warn "Discarding local $label changes."
        git -C "$dir" checkout . 2>/dev/null || true
        git -C "$dir" clean -fd 2>/dev/null || true
        run_with_timeout 60 git -C "$dir" pull --ff-only --no-recurse-submodules \
          || { error "Pull failed for $label."; exit 1; }
        ;;
    esac
  else
    info "Pulling $label ..."
    run_with_timeout 60 git -C "$dir" pull --ff-only --no-recurse-submodules \
      || { error "Pull failed for $label."; exit 1; }
  fi
}

detect_python() {
  for cmd in python3 python; do
    if command -v "$cmd" &>/dev/null; then
      local ver
      ver=$("$cmd" -c 'import sys; print(sys.version_info[:2] >= (3,9))' 2>/dev/null || echo "False")
      if [ "$ver" = "True" ]; then
        echo "$cmd"
        return
      fi
    fi
  done
  error "Python 3.9+ not found."
  local os_name
  os_name="$(uname -s)"
  case "$os_name" in
    Darwin) echo "  brew install python3" ;;
    Linux)  echo "  sudo apt install python3 python3-venv  (Debian/Ubuntu)"
            echo "  sudo dnf install python3              (Fedora/RHEL)" ;;
  esac
  exit 1
}

# Detect the system package manager on Linux.
pkg_install() {
  if command -v apt-get &>/dev/null; then
    sudo apt-get update -qq && sudo apt-get install -y -qq "$@"
  elif command -v dnf &>/dev/null; then
    sudo dnf install -y -q "$@"
  elif command -v yum &>/dev/null; then
    sudo yum install -y -q "$@"
  elif command -v pacman &>/dev/null; then
    sudo pacman -S --noconfirm --needed "$@"
  elif command -v apk &>/dev/null; then
    sudo apk add --quiet "$@"
  else
    error "No supported package manager found. Install manually: $*"
    return 1
  fi
}

# ── Platform checks ──

info "LiteLLM Proxy Installer (fork: 0xxmemo/litellm)"
echo ""

PYTHON="$(detect_python)"
PY_VERSION="$($PYTHON --version 2>&1)"
OS_NAME="$(uname -s)"
echo "  Platform: $OS_NAME (${OSTYPE:-unknown})"
echo "  Python:   $PY_VERSION ($PYTHON)"
echo ""

if [ "$OS_NAME" = "Linux" ]; then
  if ! $PYTHON -c "import venv" 2>/dev/null; then
    warn "python3-venv not found — installing ..."
    pkg_install python3-venv || true
  fi
  if ! $PYTHON -c "import ensurepip" 2>/dev/null; then
    warn "python3-pip/ensurepip not found — installing ..."
    pkg_install python3-pip || true
  fi
fi

# ── Parent repo sync ──

if [ -d "$PROJECT_DIR/.git" ]; then
  info "Checking parent repo ..."
  sync_repo "$PROJECT_DIR" "parent repo"
fi

# ── Submodule ──

if [ ! -f "$SUBMODULE_DIR/pyproject.toml" ]; then
  info "Initializing litellm submodule ..."
  run_with_timeout 120 git -C "$PROJECT_DIR" submodule update --init --depth 1 litellm
elif has_local_changes "$SUBMODULE_DIR"; then
  choice=$(prompt_local_changes "$SUBMODULE_DIR" "litellm/ submodule")
  case "$choice" in
    keep)
      info "Keeping local submodule files. Skipping sync."
      ;;
    stash)
      info "Stashing submodule changes ..."
      git -C "$SUBMODULE_DIR" stash --quiet
      info "Syncing litellm submodule ..."
      run_with_timeout 30 git -C "$PROJECT_DIR" submodule sync --recursive
      run_with_timeout 120 git -C "$PROJECT_DIR" submodule update --init --depth 1 --force litellm
      info "Restoring stashed submodule changes ..."
      git -C "$SUBMODULE_DIR" stash pop --quiet 2>/dev/null || {
        warn "Could not auto-restore submodule changes. Check: git -C $SUBMODULE_DIR stash list"
      }
      ;;
    discard)
      warn "Discarding local submodule changes."
      info "Syncing litellm submodule ..."
      run_with_timeout 30 git -C "$PROJECT_DIR" submodule sync --recursive
      run_with_timeout 120 git -C "$PROJECT_DIR" submodule update --init --depth 1 --force litellm
      ;;
  esac
else
  info "Syncing litellm submodule ..."
  run_with_timeout 30 git -C "$PROJECT_DIR" submodule sync --recursive
  run_with_timeout 120 git -C "$PROJECT_DIR" submodule update --init --depth 1 --force litellm
fi

# ── Virtualenv ──

if [ -d "$VENV_DIR" ]; then
  if [ "${LITELLM_REINSTALL_VENV:-}" = "1" ]; then
    info "Rebuilding virtualenv ..."
    rm -rf "$VENV_DIR"
    $PYTHON -m venv "$VENV_DIR"
  else
    info "Reusing existing virtualenv."
  fi
else
  info "Creating virtualenv at $VENV_DIR ..."
  $PYTHON -m venv "$VENV_DIR"
fi

# ── Activate ──

# shellcheck disable=SC1091
source "$VENV_DIR/bin/activate"

# ── Install dependencies ──

info "Upgrading pip ..."
pip install --upgrade pip --quiet

info "Installing litellm[proxy] (editable) ..."
pip install -e "$SUBMODULE_DIR[proxy]" --quiet
info "litellm installed."

# ── .env setup ──

if [ ! -f "$PROJECT_DIR/.env" ]; then
  if [ -f "$PROJECT_DIR/.env.example" ]; then
    cp "$PROJECT_DIR/.env.example" "$PROJECT_DIR/.env"
    sed -i.bak "s|/path/to/.litellm|$PROJECT_DIR|g" "$PROJECT_DIR/.env" 2>/dev/null || true
    rm -f "$PROJECT_DIR/.env.bak"
    warn "Created .env from template — edit to add your API keys"
  else
    warn "No .env file found. Copy the example and fill in your keys:"
    echo "  cp $PROJECT_DIR/.env.example $PROJECT_DIR/.env"
  fi
fi

# ── Sync auth file paths ──

"$BIN_DIR/litellmctl" init-env 2>/dev/null || true

# ── Shell completions ──

"$BIN_DIR/litellmctl" setup-completions 2>/dev/null || true

echo ""
info "Installation complete!"
echo ""
